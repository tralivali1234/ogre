<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OGRE: Hardware Buffers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="doxygen-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.0git</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('Hardware-Buffers.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Hardware Buffers </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Buffer-Usage">Buffer Usage</a><ul><li class="level2"><a href="#Shadow-Buffers">Shadow Buffers</a></li>
<li class="level2"><a href="#Locking-buffers">Locking buffers</a></li>
<li class="level2"><a href="#Practical-Buffer-Tips">Practical Buffer Tips</a></li>
</ul>
</li>
<li class="level1"><a href="#Hardware-Vertex-Buffers">Hardware Vertex Buffers</a><ul><li class="level2"><a href="#The-VertexData-class">The VertexData class</a></li>
<li class="level2"><a href="#Vertex-Declarations">Vertex Declarations</a></li>
<li class="level2"><a href="#Important-Considerations">Important Considerations</a></li>
<li class="level2"><a href="#Vertex-Buffer-Bindings">Vertex Buffer Bindings</a></li>
<li class="level2"><a href="#Creating-the-Vertex-Buffer">Creating the Vertex Buffer</a></li>
<li class="level2"><a href="#Binding-the-Vertex-Buffer">Binding the Vertex Buffer</a></li>
<li class="level2"><a href="#Updating-Vertex-Buffers">Updating Vertex Buffers</a></li>
</ul>
</li>
<li class="level1"><a href="#Hardware-Index-Buffers">Hardware Index Buffers</a><ul><li class="level2"><a href="#The-IndexData-class">The IndexData class</a></li>
<li class="level2"><a href="#Updating-Index-Buffers">Updating Index Buffers</a></li>
</ul>
</li>
<li class="level1"><a href="#Hardware-Pixel-Buffers">Hardware Pixel Buffers</a><ul><li class="level2"><a href="#Textures">Textures</a><ul><li class="level3"><a href="#Creating-a-texture">Creating a texture</a></li>
<li class="level3"><a href="#Texture-usages">Texture usages</a></li>
</ul>
</li>
<li class="level2"><a href="#Getting-a-PixelBuffer">Getting a PixelBuffer</a></li>
<li class="level2"><a href="#Updating-Pixel-Buffers">Updating Pixel Buffers</a></li>
<li class="level2"><a href="#blitFromMemory">Blit from memory</a></li>
<li class="level2"><a href="#Direct-memory-locking">Direct memory locking</a></li>
<li class="level2"><a href="#Texture-Types">Texture Types</a></li>
<li class="level2"><a href="#Cube-map-textures">Cube map textures</a></li>
<li class="level2"><a href="#Pixel-Formats">Pixel Formats</a></li>
<li class="level2"><a href="#Colour-channels">Colour channels</a></li>
<li class="level2"><a href="#Complete-list-of-pixel-formats">Complete list of pixel formats</a></li>
<li class="level2"><a href="#Pixel-boxes">Pixel boxes</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Vertex buffers, index buffers and pixel buffers inherit most of their features from the HardwareBuffer class. The general premise with a hardware buffer is that it is an area of memory with which you can do whatever you like; there is no format (vertex or otherwise) associated with the buffer itself - that is entirely up to interpretation by the methods that use it - in that way, a HardwareBuffer is just like an area of memory you might allocate using ’malloc’ - the difference being that this memory is likely to be located in GPU or AGP memory.</p>
<p><a class="anchor" id="The-Hardware-Buffer-Manager"></a> <a class="anchor" id="The-Hardware-Buffer-Manager-1"></a></p>
<h1>The Hardware Buffer Manager</h1>
<p>The HardwareBufferManager class is the factory hub of all the objects in the new geometry system. You create and destroy the majority of the objects you use to define geometry through this class. It’s a Singleton, so you access it by doing HardwareBufferManager::getSingleton() - however be aware that it is only guaranteed to exist after the RenderSystem has been initialised (after you call Root::initialise); this is because the objects created are invariably API-specific, although you will deal with them through one common interface. For example:</p>
<div class="fragment"><div class="line">VertexDeclaration* decl = HardwareBufferManager::getSingleton().createVertexDeclaration();</div></div><!-- fragment --><div class="fragment"><div class="line">HardwareVertexBufferSharedPtr vbuf = </div><div class="line">    HardwareBufferManager::getSingleton().createVertexBuffer(</div><div class="line">        3*<span class="keyword">sizeof</span>(<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>), <span class="comment">// size of one whole vertex</span></div><div class="line">        numVertices, <span class="comment">// number of vertices</span></div><div class="line">        HardwareBuffer::HBU_STATIC_WRITE_ONLY, <span class="comment">// usage</span></div><div class="line">        <span class="keyword">false</span>); <span class="comment">// no shadow buffer</span></div></div><!-- fragment --><p>Don’t worry about the details of the above, we’ll cover that in the later sections. The important thing to remember is to always create objects through the HardwareBufferManager, don’t use ’new’ (it won’t work anyway in most cases).</p>
<h1><a class="anchor" id="Buffer-Usage"></a>
Buffer Usage</h1>
<p>Because the memory in a hardware buffer is likely to be under significant contention during the rendering of a scene, the kind of access you need to the buffer over the time it is used is extremely important; whether you need to update the contents of the buffer regularly, whether you need to be able to read information back from it, these are all important factors to how the graphics card manages the buffer. The method and exact parameters used to create a buffer depends on whether you are creating an index or vertex buffer (See <a href="#Hardware-Vertex-Buffers">Hardware Vertex Buffers</a> and See <a href="#Hardware-Index-Buffers">Hardware Index Buffers</a>), however one creation parameter is common to them both - the ’usage’. The most optimal type of hardware buffer is one which is not updated often, and is never read from. The usage parameter of createVertexBuffer or createIndexBuffer can be one of the following:</p>
<dl compact="compact">
<dt><code>HBU_STATIC</code> </dt>
<dd><p class="startdd"></p>
<p>This means you do not need to update the buffer very often, but you might occasionally want to read from it.</p>
<p class="enddd"></p>
</dd>
<dt><code>HBU_STATIC_WRITE_ONLY</code> </dt>
<dd><p class="startdd"></p>
<p>This means you do not need to update the buffer very often, and you do not need to read from it. However, you may read from it’s shadow buffer if you set one up (See <a href="#Shadow-Buffers">Shadow Buffers</a>). This is the optimal buffer usage setting.</p>
<p class="enddd"></p>
</dd>
<dt><code>HBU_DYNAMIC</code> </dt>
<dd><p class="startdd"></p>
<p>This means you expect to update the buffer often, and that you may wish to read from it. This is the least optimal buffer setting.</p>
<p class="enddd"></p>
</dd>
<dt><code>HBU_DYNAMIC_WRITE_ONLY</code> </dt>
<dd><p class="startdd"></p>
<p>This means you expect to update the buffer often, but that you never want to read from it. However, you may read from it’s shadow buffer if you set one up (See <a href="#Shadow-Buffers">Shadow Buffers</a>). If you use this option, and replace the entire contents of the buffer every frame, then you should use HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE instead, since that has better performance characteristics on some platforms.</p>
<p class="enddd"></p>
</dd>
<dt><code>HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE</code> </dt>
<dd><p class="startdd"></p>
<p>This means that you expect to replace the entire contents of the buffer on an extremely regular basis, most likely every frame. By selecting this option, you free the system up from having to be concerned about losing the existing contents of the buffer at any time, because if it does lose them, you will be replacing them next frame anyway. On some platforms this can make a significant performance difference, so you should try to use this whenever you have a buffer you need to update regularly. Note that if you create a buffer this way, you should use the HBL_DISCARD flag when locking the contents of it for writing.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>Choosing the usage of your buffers carefully is important to getting optimal performance out of your geometry. If you have a situation where you need to update a vertex buffer often, consider whether you actually need to update <b>all</b> the parts of it, or just some. If it’s the latter, consider using more than one buffer, with only the data you need to modify in the HBU_DYNAMIC buffer. Always try to use the _WRITE_ONLY forms. This just means that you cannot read <em>directly</em> from the hardware buffer, which is good practice because reading from hardware buffers is very slow. If you really need to read data back, use a shadow buffer, described in the next section.</p>
<h2><a class="anchor" id="Shadow-Buffers"></a>
Shadow Buffers</h2>
<p>As discussed in the previous section, reading data back from a hardware buffer performs very badly. However, if you have a cast-iron need to read the contents of the vertex buffer, you should set the ’shadowBuffer’ parameter of createVertexBuffer or createIndexBuffer to ’true’. This causes the hardware buffer to be backed with a system memory copy, which you can read from with no more penalty than reading ordinary memory. The catch is that when you write data into this buffer, it will first update the system memory copy, then it will update the hardware buffer, as separate copying process - therefore this technique has an additional overhead when writing data. Don’t use it unless you really need it.</p>
<h2><a class="anchor" id="Locking-buffers"></a>
Locking buffers</h2>
<p>In order to read or update a hardware buffer, you have to ’lock’ it. This performs 2 functions - it tells the card that you want access to the buffer (which can have an effect on its rendering queue), and it returns a pointer which you can manipulate. Note that if you’ve asked to read the buffer (and remember, you really shouldn’t unless you’ve set the buffer up with a shadow buffer), the contents of the hardware buffer will have been copied into system memory somewhere in order for you to get access to it. For the same reason, when you’re finished with the buffer you must unlock it; if you locked the buffer for writing this will trigger the process of uploading the modified information to the graphics hardware.</p>
<p><a class="anchor" id="Lock-parameters"></a></p>
<h3>Lock parameters</h3>
<p>When you lock a buffer, you call one of the following methods:</p>
<div class="fragment"><div class="line"><span class="comment">// Lock the entire buffer</span></div><div class="line">pBuffer-&gt;lock(lockType);</div><div class="line"><span class="comment">// Lock only part of the buffer</span></div><div class="line">pBuffer-&gt;lock(start, length, lockType);</div></div><!-- fragment --><p>The first call locks the entire buffer, the second locks only the section from ’start’ (as a byte offset), for ’length’ bytes. This could be faster than locking the entire buffer since less is transferred, but not if you later update the rest of the buffer too, because doing it in small chunks like this means you cannot use HBL_DISCARD (see below). The lockType parameter can have a large effect on the performance of your application, especially if you are not using a shadow buffer.</p>
<dl compact="compact">
<dt><code>HBL_NORMAL</code> </dt>
<dd><p class="startdd"></p>
<p>This kind of lock allows reading and writing from the buffer - it’s also the least optimal because basically you’re telling the card you could be doing anything at all. If you’re not using a shadow buffer, it requires the buffer to be transferred from the card and back again. If you’re using a shadow buffer the effect is minimal.</p>
<p class="enddd"></p>
</dd>
<dt><code>HBL_READ_ONLY</code> </dt>
<dd><p class="startdd"></p>
<p>This means you only want to read the contents of the buffer. Best used when you created the buffer with a shadow buffer because in that case the data does not have to be downloaded from the card.</p>
<p class="enddd"></p>
</dd>
<dt><code>HBL_DISCARD</code> </dt>
<dd><p class="startdd"></p>
<p>This means you are happy for the card to discard the <em>entire current contents</em> of the buffer. Implicitly this means you are not going to read the data - it also means that the card can avoid any stalls if the buffer is currently being rendered from, because it will actually give you an entirely different one. Use this wherever possible when you are locking a buffer which was not created with a shadow buffer. If you are using a shadow buffer it matters less, although with a shadow buffer it’s preferable to lock the entire buffer at once, because that allows the shadow buffer to use HBL_DISCARD when it uploads the updated contents to the real buffer.</p>
<p class="enddd"></p>
</dd>
<dt><code>HBL_NO_OVERWRITE</code> </dt>
<dd><p class="startdd"></p>
<p>This is useful if you are locking just part of the buffer and thus cannot use HBL_DISCARD. It tells the card that you promise not to modify any section of the buffer which has already been used in a rendering operation this frame. Again this is only useful on buffers with no shadow buffer.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>Once you have locked a buffer, you can use the pointer returned however you wish (just don’t bother trying to read the data that’s there if you’ve used HBL_DISCARD, or write the data if you’ve used HBL_READ_ONLY). Modifying the contents depends on the type of buffer, See <a href="#Hardware-Vertex-Buffers">Hardware Vertex Buffers</a> and See <a href="#Hardware-Index-Buffers">Hardware Index Buffers</a></p>
<h2><a class="anchor" id="Practical-Buffer-Tips"></a>
Practical Buffer Tips</h2>
<p>The interplay of usage mode on creation, and locking options when reading / updating is important for performance. Here’s some tips:</p>
<ol type="1">
<li>Aim for the ’perfect’ buffer by creating with HBU_STATIC_WRITE_ONLY, with no shadow buffer, and locking all of it once only with HBL_DISCARD to populate it. Never touch it again.</li>
<li>If you need to update a buffer regularly, you will have to compromise. Use HBU_DYNAMIC_WRITE_ONLY when creating (still no shadow buffer), and use HBL_DISCARD to lock the entire buffer, or if you can’t then use HBL_NO_OVERWRITE to lock parts of it.</li>
<li>If you really need to read data from the buffer, create it with a shadow buffer. Make sure you use HBL_READ_ONLY when locking for reading because it will avoid the upload normally associated with unlocking the buffer. You can also combine this with either of the 2 previous points, obviously try for static if you can - remember that the _WRITE_ONLY’ part refers to the hardware buffer so can be safely used with a shadow buffer you read from.</li>
<li>Split your vertex buffers up if you find that your usage patterns for different elements of the vertex are different. No point having one huge updatable buffer with all the vertex data in it, if all you need to update is the texture coordinates. Split that part out into it’s own buffer and make the rest HBU_STATIC_WRITE_ONLY.</li>
</ol>
<h1><a class="anchor" id="Hardware-Vertex-Buffers"></a>
Hardware Vertex Buffers</h1>
<p>This section covers specialised hardware buffers which contain vertex data. For a general discussion of hardware buffers, along with the rules for creating and locking them, see the <a href="#Hardware-Buffers">Hardware Buffers</a> section.</p>
<h2><a class="anchor" id="The-VertexData-class"></a>
The VertexData class</h2>
<p>The VertexData class collects together all the vertex-related information used to render geometry. The new RenderOperation requires a pointer to a VertexData object, and it is also used in Mesh and SubMesh to store the vertex positions, normals, texture coordinates etc. VertexData can either be used alone (in order to render unindexed geometry, where the stream of vertices defines the triangles), or in combination with IndexData where the triangles are defined by indexes which refer to the entries in VertexData. It’s worth noting that you don’t necessarily have to use VertexData to store your applications geometry; all that is required is that you can build a VertexData structure when it comes to rendering. This is pretty easy since all of VertexData’s members are pointers, so you could maintain your vertex buffers and declarations in alternative structures if you like, so long as you can convert them for rendering. The VertexData class has a number of important members:</p>
<dl compact="compact">
<dt>vertexStart </dt>
<dd><p class="startdd"></p>
<p>The position in the bound buffers to start reading vertex data from. This allows you to use a single buffer for many different renderables.</p>
<p class="enddd"></p>
</dd>
<dt>vertexCount </dt>
<dd><p class="startdd"></p>
<p>The number of vertices to process in this particular rendering group</p>
<p class="enddd"></p>
</dd>
<dt>vertexDeclaration </dt>
<dd><p class="startdd"></p>
<p>A pointer to a VertexDeclaration object which defines the format of the vertex input; note this is created for you by VertexData. See <a href="#Vertex-Declarations">Vertex Declarations</a></p>
<p class="enddd"></p>
</dd>
<dt>vertexBufferBinding </dt>
<dd><p class="startdd"></p>
<p>A pointer to a VertexBufferBinding object which defines which vertex buffers are bound to which sources - again, this is created for you by VertexData. See <a href="#Vertex-Buffer-Bindings">Vertex Buffer Bindings</a></p>
<p class="enddd"></p>
</dd>
</dl>
<h2><a class="anchor" id="Vertex-Declarations"></a>
Vertex Declarations</h2>
<p>Vertex declarations define the vertex inputs used to render the geometry you want to appear on the screen. Basically this means that for each vertex, you want to feed a certain set of data into the graphics pipeline, which (you hope) will affect how it all looks when the triangles are drawn. Vertex declarations let you pull items of data (which we call vertex elements, represented by the VertexElement class) from any number of buffers, both shared and dedicated to that particular element. It’s your job to ensure that the contents of the buffers make sense when interpreted in the way that your VertexDeclaration indicates that they should. To add an element to a VertexDeclaration, you call it’s addElement method. The parameters to this method are:</p>
<dl compact="compact">
<dt>source </dt>
<dd><p class="startdd"></p>
<p>This tells the declaration which buffer the element is to be pulled from. Note that this is just an index, which may range from 0 to one less than the number of buffers which are being bound as sources of vertex data. See <a href="#Vertex-Buffer-Bindings">Vertex Buffer Bindings</a> for information on how a real buffer is bound to a source index. Storing the source of the vertex element this way (rather than using a buffer pointer) allows you to rebind the source of a vertex very easily, without changing the declaration of the vertex format itself.</p>
<p class="enddd"></p>
</dd>
<dt>offset </dt>
<dd><p class="startdd"></p>
<p>Tells the declaration how far in bytes the element is offset from the start of each whole vertex in this buffer. This will be 0 if this is the only element being sourced from this buffer, but if other elements are there then it may be higher. A good way of thinking of this is the size of all vertex elements which precede this element in the buffer.</p>
<p class="enddd"></p>
</dd>
<dt>type </dt>
<dd><p class="startdd"></p>
<p>This defines the data type of the vertex input, including it’s size. This is an important element because as GPUs become more advanced, we can no longer assume that position input will always require 3 floating point numbers, because programmable vertex pipelines allow full control over the inputs and outputs. This part of the element definition covers the basic type and size, e.g. VET_FLOAT3 is 3 floating point numbers - the meaning of the data is dealt with in the next parameter.</p>
<p class="enddd"></p>
</dd>
<dt>semantic </dt>
<dd><p class="startdd"></p>
<p>This defines the meaning of the element - the GPU will use this to determine what to use this input for, and programmable vertex pipelines will use this to identify which semantic to map the input to. This can identify the element as positional data, normal data, texture coordinate data, etc. See the API reference for full details of all the options.</p>
<p class="enddd"></p>
</dd>
<dt>index </dt>
<dd><p class="startdd"></p>
<p>This parameter is only required when you supply more than one element of the same semantic in one vertex declaration. For example, if you supply more than one set of texture coordinates, you would set first sets index to 0, and the second set to 1.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>You can repeat the call to addElement for as many elements as you have in your vertex input structures. There are also useful methods on VertexDeclaration for locating elements within a declaration - see the API reference for full details.</p>
<h2><a class="anchor" id="Important-Considerations"></a>
Important Considerations</h2>
<p>Whilst in theory you have completely full reign over the format of you vertices, in reality there are some restrictions. Older DirectX hardware imposes a fixed ordering on the elements which are pulled from each buffer; specifically any hardware prior to DirectX 9 may impose the following restrictions:</p>
<ul>
<li>VertexElements should be added in the following order, and the order of the elements within any shared buffer should be as follows:<ol type="1">
<li>Positions</li>
<li>Blending weights</li>
<li>Normals</li>
<li>Diffuse colours</li>
<li>Specular colours</li>
<li>Texture coordinates (starting at 0, listed in order, with no gaps)</li>
</ol>
</li>
<li>You must not have unused gaps in your buffers which are not referenced by any VertexElement</li>
<li>You must not cause the buffer &amp; offset settings of 2 VertexElements to overlap</li>
</ul>
<p>OpenGL and DirectX 9 compatible hardware are not required to follow these strict limitations, so you might find, for example that if you broke these rules your application would run under OpenGL and under DirectX on recent cards, but it is not guaranteed to run on older hardware under DirectX unless you stick to the above rules. For this reason you’re advised to abide by them!</p>
<h2><a class="anchor" id="Vertex-Buffer-Bindings"></a>
Vertex Buffer Bindings</h2>
<p>Vertex buffer bindings are about associating a vertex buffer with a source index used in <a href="#Vertex-Declarations">Vertex Declarations</a>.</p>
<h2><a class="anchor" id="Creating-the-Vertex-Buffer"></a>
Creating the Vertex Buffer</h2>
<p>Firstly, lets look at how you create a vertex buffer:</p>
<div class="fragment"><div class="line">HardwareVertexBufferSharedPtr vbuf = </div><div class="line">    HardwareBufferManager::getSingleton().createVertexBuffer(</div><div class="line">        3*<span class="keyword">sizeof</span>(<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>), <span class="comment">// size of one whole vertex</span></div><div class="line">        numVertices, <span class="comment">// number of vertices</span></div><div class="line">        HardwareBuffer::HBU_STATIC_WRITE_ONLY, <span class="comment">// usage</span></div><div class="line">        <span class="keyword">false</span>); <span class="comment">// no shadow buffer</span></div></div><!-- fragment --><p>Notice that we use <a href="#The-Hardware-Buffer-Manager">The Hardware Buffer Manager</a> to create our vertex buffer, and that a class called HardwareVertexBufferSharedPtr is returned from the method, rather than a raw pointer. This is because vertex buffers are reference counted - you are able to use a single vertex buffer as a source for multiple pieces of geometry therefore a standard pointer would not be good enough, because you would not know when all the different users of it had finished with it. The HardwareVertexBufferSharedPtr class manages its own destruction by keeping a reference count of the number of times it is being used - when the last HardwareVertexBufferSharedPtr is destroyed, the buffer itself automatically destroys itself.</p>
<p>The parameters to the creation of a vertex buffer are as follows:</p>
<dl compact="compact">
<dt>vertexSize </dt>
<dd><p class="startdd"></p>
<p>The size in bytes of a whole vertex in this buffer. A vertex may include multiple elements, and in fact the contents of the vertex data may be reinterpreted by different vertex declarations if you wish. Therefore you must tell the buffer manager how large a whole vertex is, but not the internal format of the vertex, since that is down to the declaration to interpret. In the above example, the size is set to the size of 3 floating point values - this would be enough to hold a standard 3D position or normal, or a 3D texture coordinate, per vertex.</p>
<p class="enddd"></p>
</dd>
<dt>numVertices </dt>
<dd><p class="startdd"></p>
<p>The number of vertices in this buffer. Remember, not all the vertices have to be used at once - it can be beneficial to create large buffers which are shared between many chunks of geometry because changing vertex buffer bindings is a render state switch, and those are best minimised.</p>
<p class="enddd"></p>
</dd>
<dt>usage </dt>
<dd><p class="startdd"></p>
<p>This tells the system how you intend to use the buffer. See <a href="#Buffer-Usage">Buffer Usage</a></p>
<p class="enddd"></p>
</dd>
<dt>useShadowBuffer </dt>
<dd><p class="startdd"></p>
<p>Tells the system whether you want this buffer backed by a system-memory copy. See <a href="#Shadow-Buffers">Shadow Buffers</a></p>
<p class="enddd"></p>
</dd>
</dl>
<h2><a class="anchor" id="Binding-the-Vertex-Buffer"></a>
Binding the Vertex Buffer</h2>
<p>The second part of the process is to bind this buffer which you have created to a source index. To do this, you call:</p>
<div class="fragment"><div class="line">vertexBufferBinding-&gt;setBinding(0, vbuf);</div></div><!-- fragment --><p>This results in the vertex buffer you created earlier being bound to source index 0, so any vertex element which is pulling its data from source index 0 will retrieve data from this buffer. There are also methods for retrieving buffers from the binding data - see the API reference for full details.</p>
<h2><a class="anchor" id="Updating-Vertex-Buffers"></a>
Updating Vertex Buffers</h2>
<p>The complexity of updating a vertex buffer entirely depends on how its contents are laid out. You can lock a buffer (See <a href="#Locking-buffers">Locking buffers</a>), but how you write data into it vert much depends on what it contains. Lets start with a vert simple example. Lets say you have a buffer which only contains vertex positions, so it only contains sets of 3 floating point numbers per vertex. In this case, all you need to do to write data into it is:</p>
<div class="fragment"><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>* pReal = <span class="keyword">static_cast&lt;</span><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>*<span class="keyword">&gt;</span>(vbuf-&gt;lock(HardwareBuffer::HBL_DISCARD));</div></div><!-- fragment --><p>... then you just write positions in chunks of 3 reals. If you have other floating point data in there, it’s a little more complex but the principle is largely the same, you just need to write alternate elements. But what if you have elements of different types, or you need to derive how to write the vertex data from the elements themselves? Well, there are some useful methods on the VertexElement class to help you out. Firstly, you lock the buffer but assign the result to a unsigned char* rather than a specific type. Then, for each element which is sourcing from this buffer (which you can find out by calling VertexDeclaration::findElementsBySource) you call VertexElement::baseVertexPointerToElement. This offsets a pointer which points at the base of a vertex in a buffer to the beginning of the element in question, and allows you to use a pointer of the right type to boot. Here’s a full example:</p>
<div class="fragment"><div class="line"><span class="comment">// Get base pointer</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* pVert = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*<span class="keyword">&gt;</span>(vbuf-&gt;lock(HardwareBuffer::HBL_READ_ONLY));</div><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>* pReal;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> v = 0; v &lt; vertexCount; ++v)</div><div class="line">{</div><div class="line">    <span class="comment">// Get elements</span></div><div class="line">    VertexDeclaration::VertexElementList elems = decl-&gt;findElementsBySource(bufferIdx);</div><div class="line">    VertexDeclaration::VertexElementList::iterator i, iend;</div><div class="line">    <span class="keywordflow">for</span> (i = elems.begin(); i != elems.end(); ++i)</div><div class="line">    {</div><div class="line">        VertexElement&amp; elem = *i;</div><div class="line">        <span class="keywordflow">if</span> (elem.getSemantic() == <a class="code" href="group___render_system.html#gga0a62b3f2ede8992ff365bb013a8bc00dad04d50e91c2ec5377e610b3f5b9b07f2">VES_POSITION</a>)</div><div class="line">        {</div><div class="line">            elem.baseVertexPointerToElement(pVert, &amp;pReal);</div><div class="line">            <span class="comment">// write position using pReal</span></div><div class="line"></div><div class="line">        }</div><div class="line"></div><div class="line">        ...</div><div class="line"></div><div class="line"></div><div class="line">    }</div><div class="line">    pVert += vbuf-&gt;getVertexSize();</div><div class="line">}</div><div class="line">vbuf-&gt;unlock();</div></div><!-- fragment --><p>See the API docs for full details of all the helper methods on VertexDeclaration and VertexElement to assist you in manipulating vertex buffer data pointers.</p>
<h1><a class="anchor" id="Hardware-Index-Buffers"></a>
Hardware Index Buffers</h1>
<p>Index buffers are used to render geometry by building triangles out of vertices indirectly by reference to their position in the buffer, rather than just building triangles by sequentially reading vertices. Index buffers are simpler than vertex buffers, since they are just a list of indexes at the end of the day, however they can be held on the hardware and shared between multiple pieces of geometry in the same way vertex buffers can, so the rules on creation and locking are the same. See <a href="#Hardware-Buffers">Hardware Buffers</a> for information.</p>
<h2><a class="anchor" id="The-IndexData-class"></a>
The IndexData class</h2>
<p>This class summarises the information required to use a set of indexes to render geometry. It’s members are as follows:</p>
<dl compact="compact">
<dt>indexStart </dt>
<dd><p class="startdd"></p>
<p>The first index used by this piece of geometry; this can be useful for sharing a single index buffer among several geometry pieces.</p>
<p class="enddd"></p>
</dd>
<dt>indexCount </dt>
<dd><p class="startdd"></p>
<p>The number of indexes used by this particular renderable.</p>
<p class="enddd"></p>
</dd>
<dt>indexBuffer </dt>
<dd><p class="startdd"></p>
<p>The index buffer which is used to source the indexes.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="Creating-an-Index-Buffer"></a></p>
<h2>Creating an Index Buffer</h2>
<p>Index buffers are created using See <a href="#The-Hardware-Buffer-Manager">The Hardware Buffer Manager</a> just like vertex buffers, here’s how:</p>
<div class="fragment"><div class="line">HardwareIndexBufferSharedPtr ibuf = HardwareBufferManager::getSingleton().</div><div class="line">    createIndexBuffer(</div><div class="line">        HardwareIndexBuffer::IT_16BIT, <span class="comment">// type of index</span></div><div class="line">        numIndexes, <span class="comment">// number of indexes</span></div><div class="line">        HardwareBuffer::HBU_STATIC_WRITE_ONLY, <span class="comment">// usage</span></div><div class="line">        <span class="keyword">false</span>); <span class="comment">// no shadow buffer </span></div></div><!-- fragment --><p>Once again, notice that the return type is a class rather than a pointer; this is reference counted so that the buffer is automatically destroyed when no more references are made to it. The parameters to the index buffer creation are:</p>
<dl compact="compact">
<dt>indexType </dt>
<dd><p class="startdd"></p>
<p>There are 2 types of index; 16-bit and 32-bit. They both perform the same way, except that the latter can address larger vertex buffers. If your buffer includes more than 65526 vertices, then you will need to use 32-bit indexes. Note that you should only use 32-bit indexes when you need to, since they incur more overhead than 16-bit vertices, and are not supported on some older hardware.</p>
<p class="enddd"></p>
</dd>
<dt>numIndexes </dt>
<dd><p class="startdd"></p>
<p>The number of indexes in the buffer. As with vertex buffers, you should consider whether you can use a shared index buffer which is used by multiple pieces of geometry, since there can be performance advantages to switching index buffers less often.</p>
<p class="enddd"></p>
</dd>
<dt>usage </dt>
<dd><p class="startdd"></p>
<p>This tells the system how you intend to use the buffer. See <a href="#Buffer-Usage">Buffer Usage</a></p>
<p class="enddd"></p>
</dd>
<dt>useShadowBuffer </dt>
<dd><p class="startdd"></p>
<p>Tells the system whether you want this buffer backed by a system-memory copy. See <a href="#Shadow-Buffers">Shadow Buffers</a></p>
<p class="enddd"></p>
</dd>
</dl>
<h2><a class="anchor" id="Updating-Index-Buffers"></a>
Updating Index Buffers</h2>
<p>Updating index buffers can only be done when you lock the buffer for writing; See <a href="#Locking-buffers">Locking buffers</a> for details. Locking returns a void pointer, which must be cast to the appropriate type; with index buffers this is either an unsigned short (for 16-bit indexes) or an unsigned long (for 32-bit indexes). For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>* pIdx = <span class="keyword">static_cast&lt;</span><span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*<span class="keyword">&gt;</span>(ibuf-&gt;lock(HardwareBuffer::HBL_DISCARD));</div></div><!-- fragment --><p>You can then write to the buffer using the usual pointer semantics, just remember to unlock the buffer when you’re finished!</p>
<h1><a class="anchor" id="Hardware-Pixel-Buffers"></a>
Hardware Pixel Buffers</h1>
<p>Hardware Pixel Buffers are a special kind of buffer that stores graphical data in graphics card memory, generally for use as textures. Pixel buffers can represent a one dimensional, two dimensional or three dimensional image. A texture can consist of a multiple of these buffers.</p>
<p>In contrary to vertex and index buffers, pixel buffers are not constructed directly. When creating a texture, the necessary pixel buffers to hold its data are constructed automatically.</p>
<h2><a class="anchor" id="Textures"></a>
Textures</h2>
<p>A texture is an image that can be applied onto the surface of a three dimensional model. In <a class="el" href="namespace_ogre.html">Ogre</a>, textures are represented by the Texture resource class.</p>
<h3><a class="anchor" id="Creating-a-texture"></a>
Creating a texture</h3>
<p>Textures are created through the TextureManager. In most cases they are created from image files directly by the <a class="el" href="namespace_ogre.html">Ogre</a> resource system. If you are reading this, you most probably want to create a texture manually so that you can provide it with image data yourself. This is done through TextureManager::createManual:</p>
<div class="fragment"><div class="line">ptex = TextureManager::getSingleton().createManual(</div><div class="line">    <span class="stringliteral">&quot;MyManualTexture&quot;</span>, <span class="comment">// Name of texture</span></div><div class="line">    <span class="stringliteral">&quot;General&quot;</span>, <span class="comment">// Name of resource group in which the texture should be created</span></div><div class="line">    <a class="code" href="group___resources.html#ggae50520af6377ff8184cf79125cb9c4d7af1f732018f5a2a7d35233e2ceeb4ee0e">TEX_TYPE_2D</a>, <span class="comment">// Texture type</span></div><div class="line">    256, <span class="comment">// Width</span></div><div class="line">    256, <span class="comment">// Height</span></div><div class="line">    1, <span class="comment">// Depth (Must be 1 for two dimensional textures)</span></div><div class="line">    0, <span class="comment">// Number of mipmaps</span></div><div class="line">    <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca0d5c9bdb0633c1849758fea566a2b754">PF_A8R8G8B8</a>, <span class="comment">// Pixel format</span></div><div class="line">    <a class="code" href="group___resources.html#ggaf140ec886884a864abc74a7556f8bf67ac26eda030d21e0491461edea89394493">TU_DYNAMIC_WRITE_ONLY</a> <span class="comment">// usage</span></div><div class="line">);</div></div><!-- fragment --><p>This example creates a texture named <em>MyManualTexture</em> in resource group <em>General</em>. It is a square <em>two dimensional</em> texture, with width 256 and height 256. It has <em>no mipmaps</em>, internal format <em>PF_A8R8G8B8</em> and usage <em>TU_DYNAMIC_WRITE_ONLY</em>.</p>
<p>The different texture types will be discussed in <a href="#Texture-Types">Texture Types</a>. Pixel formats are summarised in <a href="#Pixel-Formats">Pixel Formats</a>.</p>
<h3><a class="anchor" id="Texture-usages"></a>
Texture usages</h3>
<p>In addition to the hardware buffer usages as described in See <a href="#Buffer-Usage">Buffer Usage</a> there are some usage flags specific to textures:</p>
<dl compact="compact">
<dt>TU_AUTOMIPMAP </dt>
<dd><p class="startdd"></p>
<p>Mipmaps for this texture will be automatically generated by the graphics hardware. The exact algorithm used is not defined, but you can assume it to be a 2x2 box filter.</p>
<p class="enddd"></p>
</dd>
<dt>TU_RENDERTARGET </dt>
<dd><p class="startdd"></p>
<p>This texture will be a render target, i.e. used as a target for render to texture. Setting this flag will ignore all other texture usages except TU_AUTOMIPMAP.</p>
<p class="enddd"></p>
</dd>
<dt>TU_DEFAULT </dt>
<dd><p class="startdd"></p>
<p>This is actually a combination of usage flags, and is equivalent to TU_AUTOMIPMAP | TU_STATIC_WRITE_ONLY. The resource system uses these flags for textures that are loaded from images.</p>
<p class="enddd"></p>
</dd>
</dl>
<h2><a class="anchor" id="Getting-a-PixelBuffer"></a>
Getting a PixelBuffer</h2>
<p>A Texture can consist of multiple PixelBuffers, one for each combo if mipmap level and face number. To get a PixelBuffer from a Texture object the method Texture::getBuffer(face, mipmap) is used:</p>
<p><em>face</em> should be zero for non-cubemap textures. For cubemap textures it identifies the face to use, which is one of the cube faces described in See <a href="#Texture-Types">Texture Types</a>.</p>
<p><em>mipmap</em> is zero for the zeroth mipmap level, one for the first mipmap level, and so on. On textures that have automatic mipmap generation (TU_AUTOMIPMAP) only level 0 should be accessed, the rest will be taken care of by the rendering API.</p>
<p>A simple example of using getBuffer is</p>
<div class="fragment"><div class="line"><span class="comment">// Get the PixelBuffer for face 0, mipmap 0.</span></div><div class="line">HardwarePixelBufferSharedPtr ptr = tex-&gt;getBuffer(0,0);</div></div><!-- fragment --><h2><a class="anchor" id="Updating-Pixel-Buffers"></a>
Updating Pixel Buffers</h2>
<p>Pixel Buffers can be updated in two different ways; a simple, convenient way and a more difficult (but in some cases faster) method. Both methods make use of PixelBox objects (See <a href="#Pixel-boxes">Pixel boxes</a>) to represent image data in memory.</p>
<h2><a class="anchor" id="blitFromMemory"></a>
Blit from memory</h2>
<p>The easy method to get an image into a PixelBuffer is by using HardwarePixelBuffer::blitFromMemory. This takes a PixelBox object and does all necessary pixel format conversion and scaling for you. For example, to create a manual texture and load an image into it, all you have to do is</p>
<div class="fragment"><div class="line"><span class="comment">// Manually loads an image and puts the contents in a manually created texture</span></div><div class="line">Image img;</div><div class="line">img.load(<span class="stringliteral">&quot;elephant.png&quot;</span>, <span class="stringliteral">&quot;General&quot;</span>);</div><div class="line"><span class="comment">// Create RGB texture with 5 mipmaps</span></div><div class="line"><a class="code" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a> tex = TextureManager::getSingleton().createManual(</div><div class="line">    <span class="stringliteral">&quot;elephant&quot;</span>,</div><div class="line">    <span class="stringliteral">&quot;General&quot;</span>,</div><div class="line">    <a class="code" href="group___resources.html#ggae50520af6377ff8184cf79125cb9c4d7af1f732018f5a2a7d35233e2ceeb4ee0e">TEX_TYPE_2D</a>,</div><div class="line">    img.getWidth(), img.getHeight(),</div><div class="line">    5, <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2542d39f6712cb6f69907330a31a9342">PF_X8R8G8B8</a>);</div><div class="line"><span class="comment">// Copy face 0 mipmap 0 of the image to face 0 mipmap 0 of the texture.</span></div><div class="line">tex-&gt;<a class="code" href="class_ogre_1_1_texture.html#a5df1d413ab5aab631adc59c9fac06d22">getBuffer</a>(0,0)-&gt;<a class="code" href="class_ogre_1_1_hardware_pixel_buffer.html#a56f6a6f97236e909f4fdeeab98f92492">blitFromMemory</a>(img.getPixelBox(0,0));</div></div><!-- fragment --><h2><a class="anchor" id="Direct-memory-locking"></a>
Direct memory locking</h2>
<p>A more advanced method to transfer image data from and to a PixelBuffer is to use locking. By locking a PixelBuffer you can directly access its contents in whatever the internal format of the buffer inside the GPU is.</p>
<div class="fragment"><div class="line">buffer-&gt;lock(HardwareBuffer::HBL_DISCARD);</div><div class="line"><span class="keyword">const</span> PixelBox &amp;pb = buffer-&gt;getCurrentLock();</div><div class="line"></div><div class="line"><a class="code" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> *data = <span class="keyword">static_cast&lt;</span><a class="code" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>*<span class="keyword">&gt;</span>(pb.data);</div><div class="line"><span class="keywordtype">size_t</span> height = pb.getHeight();</div><div class="line"><span class="keywordtype">size_t</span> width = pb.getWidth();</div><div class="line"><span class="keywordtype">size_t</span> pitch = pb.rowPitch; <span class="comment">// Skip between rows of image</span></div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> y=0; y&lt;height; ++y)</div><div class="line">{</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">size_t</span> x=0; x&lt;width; ++x)</div><div class="line">    {</div><div class="line">        <span class="comment">// 0xRRGGBB -&gt; fill the buffer with yellow pixels</span></div><div class="line">        data[pitch*y + x] = 0x00FFFF00;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">buffer-&gt;unlock();</div></div><!-- fragment --><h2><a class="anchor" id="Texture-Types"></a>
Texture Types</h2>
<p>There are four types of textures supported by current hardware, three of them only differ in the amount of dimensions they have (one, two or three). The fourth one is special. The different texture types are:</p>
<dl compact="compact">
<dt>TEX_TYPE_1D </dt>
<dd><p class="startdd"></p>
<p>One dimensional texture, used in combination with 1D texture coordinates.</p>
<p class="enddd"></p>
</dd>
<dt>TEX_TYPE_2D </dt>
<dd><p class="startdd"></p>
<p>Two dimensional texture, used in combination with 2D texture coordinates.</p>
<p class="enddd"></p>
</dd>
<dt>TEX_TYPE_3D </dt>
<dd><p class="startdd"></p>
<p>Three dimensional volume texture, used in combination with 3D texture coordinates.</p>
<p class="enddd"></p>
</dd>
<dt>TEX_TYPE_CUBE_MAP </dt>
<dd><p class="startdd"></p>
<p>Cube map (six two dimensional textures, one for each cube face), used in combination with 3D texture coordinates.</p>
<p class="enddd"></p>
</dd>
</dl>
<h2><a class="anchor" id="Cube-map-textures"></a>
Cube map textures</h2>
<p>The cube map texture type (TEX_TYPE_CUBE_MAP) is a different beast from the others; a cube map texture represents a series of six two dimensional images addressed by 3D texture coordinates.</p>
<dl compact="compact">
<dt>+X (face 0) </dt>
<dd><p class="startdd"></p>
<p>Represents the positive x plane (right).</p>
<p class="enddd"></p>
</dd>
<dt>-X (face 1) </dt>
<dd><p class="startdd"></p>
<p>Represents the negative x plane (left).</p>
<p class="enddd"></p>
</dd>
<dt>+Y (face 2) </dt>
<dd><p class="startdd"></p>
<p>Represents the positive y plane (top).</p>
<p class="enddd"></p>
</dd>
<dt>-Y (face 3) </dt>
<dd><p class="startdd"></p>
<p>Represents the negative y plane (bottom).</p>
<p class="enddd"></p>
</dd>
<dt>+Z (face 4) </dt>
<dd><p class="startdd"></p>
<p>Represents the positive z plane (front).</p>
<p class="enddd"></p>
</dd>
<dt>-Z (face 5) </dt>
<dd><p class="startdd"></p>
<p>Represents the negative z plane (back).</p>
<p class="enddd"></p>
</dd>
</dl>
<h2><a class="anchor" id="Pixel-Formats"></a>
Pixel Formats</h2>
<p>A pixel format described the storage format of pixel data. It defines the way pixels are encoded in memory. The following classes of pixel formats (PF_*) are defined:</p>
<dl compact="compact">
<dt>Native endian formats (PF_A8R8G8B8 and other formats with bit counts) </dt>
<dd><p class="startdd"></p>
<p>These are native endian (16, 24 and 32 bit) integers in memory. This means that an image with format PF_A8R8G8B8 can be seen as an array of 32 bit integers, defined as 0xAARRGGBB in hexadecimal. The meaning of the letters is described below.</p>
<p class="enddd"></p>
</dd>
<dt>Byte formats (PF_BYTE_*) </dt>
<dd><p class="startdd"></p>
<p>These formats have one byte per channel, and their channels in memory are organized in the order they are specified in the format name. For example, PF_BYTE_RGBA consists of blocks of four bytes, one for red, one for green, one for blue, one for alpha.</p>
<p class="enddd"></p>
</dd>
<dt>Short formats (PF_SHORT_*) </dt>
<dd><p class="startdd"></p>
<p>These formats have one unsigned short (16 bit integer) per channel, and their channels in memory are organized in the order they are specified in the format name. For example, PF_SHORT_RGBA consists of blocks of four 16 bit integers, one for red, one for green, one for blue, one for alpha.</p>
<p class="enddd"></p>
</dd>
<dt>Float16 formats (PF_FLOAT16_*) </dt>
<dd><p class="startdd"></p>
<p>These formats have one 16 bit floating point number per channel, and their channels in memory are organized in the order they are specified in the format name. For example, PF_FLOAT16_RGBA consists of blocks of four 16 bit floats, one for red, one for green, one for blue, one for alpha. The 16 bit floats, also called half float) are very similar to the IEEE single-precision floating-point standard of the 32 bits floats, except that they have only 5 exponent bits and 10 mantissa. Note that there is no standard C++ data type or CPU support to work with these efficiently, but GPUs can calculate with these much more efficiently than with 32 bit floats.</p>
<p class="enddd"></p>
</dd>
<dt>Float32 formats (PF_FLOAT32_*) </dt>
<dd><p class="startdd"></p>
<p>These formats have one 32 bit floating point number per channel, and their channels in memory are organized in the order they are specified in the format name. For example, PF_FLOAT32_RGBA consists of blocks of four 32 bit floats, one for red, one for green, one for blue, one for alpha. The C++ data type for these 32 bits floats is just "float".</p>
<p class="enddd"></p>
</dd>
<dt>Compressed formats (PF_DXT[1-5]) </dt>
<dd><p class="startdd"></p>
<p>S3TC compressed texture formats, a good description can be found at | Wikipedia (<a href="http://en.wikipedia.org/wiki/S3TC">http://en.wikipedia.org/wiki/S3TC</a>)</p>
<p class="enddd"></p>
</dd>
</dl>
<h2><a class="anchor" id="Colour-channels"></a>
Colour channels</h2>
<p>The meaning of the channels R,G,B,A,L and X is defined as</p>
<dl compact="compact">
<dt>R </dt>
<dd><p class="startdd"></p>
<p>Red colour component, usually ranging from 0.0 (no red) to 1.0 (full red).</p>
<p class="enddd"></p>
</dd>
<dt>G </dt>
<dd><p class="startdd"></p>
<p>Green colour component, usually ranging from 0.0 (no green) to 1.0 (full green).</p>
<p class="enddd"></p>
</dd>
<dt>B </dt>
<dd><p class="startdd"></p>
<p>Blue colour component, usually ranging from 0.0 (no blue) to 1.0 (full blue).</p>
<p class="enddd"></p>
</dd>
<dt>A </dt>
<dd><p class="startdd"></p>
<p>Alpha component, usually ranging from 0.0 (entire transparent) to 1.0 (opaque).</p>
<p class="enddd"></p>
</dd>
<dt>L </dt>
<dd><p class="startdd"></p>
<p>Luminance component, usually ranging from 0.0 (black) to 1.0 (white). The luminance component is duplicated in the R, G, and B channels to achieve a greyscale image.</p>
<p class="enddd"></p>
</dd>
<dt>X </dt>
<dd><p class="startdd"></p>
<p>This component is completely ignored.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>If none of red, green and blue components, or luminance is defined in a format, these default to 0. For the alpha channel this is different; if no alpha is defined, it defaults to 1.</p>
<h2><a class="anchor" id="Complete-list-of-pixel-formats"></a>
Complete list of pixel formats</h2>
<p>This pixel formats supported by the current version of <a class="el" href="namespace_ogre.html">Ogre</a> are</p>
<dl compact="compact">
<dt>Byte formats </dt>
<dd><p class="startdd"></p>
<p>PF_BYTE_RGB, PF_BYTE_BGR, PF_BYTE_BGRA, PF_BYTE_RGBA, PF_BYTE_L, PF_BYTE_LA, PF_BYTE_A</p>
<p class="enddd"></p>
</dd>
<dt>Short formats </dt>
<dd><p class="startdd"></p>
<p>PF_SHORT_RGBA</p>
<p class="enddd"></p>
</dd>
<dt>Float16 formats </dt>
<dd><p class="startdd"></p>
<p>PF_FLOAT16_R, PF_FLOAT16_RGB, PF_FLOAT16_RGBA</p>
<p class="enddd"></p>
</dd>
<dt>Float32 formats </dt>
<dd><p class="startdd"></p>
<p>PF_FLOAT32_R, PF_FLOAT32_RGB, PF_FLOAT32_RGBA</p>
<p class="enddd"></p>
</dd>
<dt>8 bit native endian formats </dt>
<dd><p class="startdd"></p>
<p>PF_L8, PF_A8, PF_A4L4, PF_R3G3B2</p>
<p class="enddd"></p>
</dd>
<dt>16 bit native endian formats </dt>
<dd><p class="startdd"></p>
<p>PF_L16, PF_R5G6B5, PF_B5G6R5, PF_A4R4G4B4, PF_A1R5G5B5</p>
<p class="enddd"></p>
</dd>
<dt>24 bit native endian formats </dt>
<dd><p class="startdd"></p>
<p>PF_R8G8B8, PF_B8G8R8</p>
<p class="enddd"></p>
</dd>
<dt>32 bit native endian formats </dt>
<dd><p class="startdd"></p>
<p>PF_A8R8G8B8, PF_A8B8G8R8, PF_B8G8R8A8, PF_R8G8B8A8, PF_X8R8G8B8, PF_X8B8G8R8, PF_A2R10G10B10 PF_A2B10G10R10</p>
<p class="enddd"></p>
</dd>
<dt>Compressed formats </dt>
<dd><p class="startdd"></p>
<p>PF_DXT1, PF_DXT2, PF_DXT3, PF_DXT4, PF_DXT5</p>
<p class="enddd"></p>
</dd>
</dl>
<h2><a class="anchor" id="Pixel-boxes"></a>
Pixel boxes</h2>
<p>All methods in <a class="el" href="namespace_ogre.html">Ogre</a> that take or return raw image data return a PixelBox object.</p>
<p>A PixelBox is a primitive describing a volume (3D), image (2D) or line (1D) of pixels in CPU memory. It describes the location and data format of a region of memory used for image data, but does not do any memory management in itself.</p>
<p>Inside the memory pointed to by the <em>data</em> member of a pixel box, pixels are stored as a succession of "depth" slices (in Z), each containing "height" rows (Y) of "width" pixels (X).</p>
<p>Dimensions that are not used must be 1. For example, a one dimensional image will have extents (width,1,1). A two dimensional image has extents (width,height,1).</p>
<p>A PixelBox has the following members:</p>
<dl compact="compact">
<dt>data </dt>
<dd><p class="startdd"></p>
<p>The pointer to the first component of the image data in memory.</p>
<p class="enddd"></p>
</dd>
<dt>format </dt>
<dd><p class="startdd"></p>
<p>The pixel format (See <a href="#Pixel-Formats">Pixel Formats</a>) of the image data.</p>
<p class="enddd"></p>
</dd>
<dt>rowPitch </dt>
<dd><p class="startdd"></p>
<p>The number of elements between the leftmost pixel of one row and the left pixel of the next. This value must always be equal to getWidth() (consecutive) for compressed formats.</p>
<p class="enddd"></p>
</dd>
<dt>slicePitch </dt>
<dd><p class="startdd"></p>
<p>The number of elements between the top left pixel of one (depth) slice and the top left pixel of the next. Must be a multiple of rowPitch. This value must always be equal to getWidth()*getHeight() (consecutive) for compressed formats.</p>
<p class="enddd"></p>
</dd>
<dt>left, top, right, bottom, front, back </dt>
<dd><p class="startdd"></p>
<p>Extents of the box in three dimensional integer space. Note that the left, top, and front edges are included but the right, bottom and top ones are not. <em>left</em> must always be smaller or equal to <em>right</em>, <em>top</em> must always be smaller or equal to <em>bottom</em>, and <em>front</em> must always be smaller or equal to <em>back</em>.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>It also has some useful methods:</p>
<dl compact="compact">
<dt>getWidth() </dt>
<dd><p class="startdd"></p>
<p>Get the width of this box</p>
<p class="enddd"></p>
</dd>
<dt>getHeight() </dt>
<dd><p class="startdd"></p>
<p>Get the height of this box. This is 1 for one dimensional images.</p>
<p class="enddd"></p>
</dd>
<dt>getDepth() </dt>
<dd><p class="startdd"></p>
<p>Get the depth of this box. This is 1 for one and two dimensional images.</p>
<p class="enddd"></p>
</dd>
<dt>setConsecutive() </dt>
<dd><p class="startdd"></p>
<p>Set the rowPitch and slicePitch so that the buffer is laid out consecutive in memory.</p>
<p class="enddd"></p>
</dd>
<dt>getRowSkip() </dt>
<dd><p class="startdd"></p>
<p>Get the number of elements between one past the rightmost pixel of one row and the leftmost pixel of the next row. This is zero if rows are consecutive.</p>
<p class="enddd"></p>
</dd>
<dt>getSliceSkip() </dt>
<dd><p class="startdd"></p>
<p>Get the number of elements between one past the right bottom pixel of one slice and the left top pixel of the next slice. This is zero if slices are consecutive.</p>
<p class="enddd"></p>
</dd>
<dt>isConsecutive() </dt>
<dd><p class="startdd"></p>
<p>Return whether this buffer is laid out consecutive in memory (i.e. the pitches are equal to the dimensions)</p>
<p class="enddd"></p>
</dd>
<dt>getConsecutiveSize() </dt>
<dd><p class="startdd"></p>
<p>Return the size (in bytes) this image would take if it was laid out consecutive in memory</p>
<p class="enddd"></p>
</dd>
<dt>getSubVolume(const Box &amp;def) </dt>
<dd><p class="startdd"></p>
<p>Return a subvolume of this PixelBox, as a PixelBox.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>For more information about these methods consult the API documentation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li>
    <li class="footer">Generated on Tue Nov 29 2016 01:11:59 for OGRE by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
