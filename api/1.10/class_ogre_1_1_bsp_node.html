<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OGRE: Ogre::BspNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="doxygen-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.0git</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_ogre_1_1_bsp_node.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_ogre_1_1_bsp_node-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::BspNode Class Reference<div class="ingroups"><a class="el" href="group___plugins.html">Plugins</a> &raquo; <a class="el" href="group___b_s_p_scene_manager.html">BSPSceneManager</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Encapsulates a node in a BSP tree.  
 <a href="class_ogre_1_1_bsp_node.html#details">More...</a></p>

<p><code>#include &lt;OgreBspNode.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::BspNode:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_bsp_node__inherit__graph.svg" width="123" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_bsp_node_1_1_brush.html">Brush</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af86ad5b76b6e2327db0e702d4216ad30"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1set.html">set</a>&lt; const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#af86ad5b76b6e2327db0e702d4216ad30">IntersectingObjectSet</a></td></tr>
<tr class="separator:af86ad5b76b6e2327db0e702d4216ad30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6cf2f9bdd72538d3b2863bfb598f98"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; <a class="el" href="struct_ogre_1_1_bsp_node_1_1_brush.html">Brush</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#ade6cf2f9bdd72538d3b2863bfb598f98">NodeBrushList</a></td></tr>
<tr class="separator:ade6cf2f9bdd72538d3b2863bfb598f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a39b74504f7252462d27f69bbeef5dc99"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a39b74504f7252462d27f69bbeef5dc99">BspNode</a> (<a class="el" href="class_ogre_1_1_bsp_level.html">BspLevel</a> *owner, bool <a class="el" href="class_ogre_1_1_bsp_node.html#a5c3f25a54f243b0bed44f446e92af533">isLeaf</a>)</td></tr>
<tr class="memdesc:a39b74504f7252462d27f69bbeef5dc99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, only to be used by <a class="el" href="class_ogre_1_1_bsp_level.html" title="Holds all the data associated with a Binary Space Parition (BSP) based indoor level. ">BspLevel</a>.  <a href="#a39b74504f7252462d27f69bbeef5dc99">More...</a><br /></td></tr>
<tr class="separator:a39b74504f7252462d27f69bbeef5dc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10395588ed29a1d34e3b028643dd2d77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a10395588ed29a1d34e3b028643dd2d77">BspNode</a> ()</td></tr>
<tr class="separator:a10395588ed29a1d34e3b028643dd2d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74871a4318ee6f0bfdf068a988bc2496"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a74871a4318ee6f0bfdf068a988bc2496">~BspNode</a> ()</td></tr>
<tr class="separator:a74871a4318ee6f0bfdf068a988bc2496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5702538be4c791af37cd73d2aa353a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#ac5702538be4c791af37cd73d2aa353a5">_addMovable</a> (const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *mov)</td></tr>
<tr class="memdesc:ac5702538be4c791af37cd73d2aa353a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for telling the node that a movable intersects it.  <a href="#ac5702538be4c791af37cd73d2aa353a5">More...</a><br /></td></tr>
<tr class="separator:ac5702538be4c791af37cd73d2aa353a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10efd90b923c891eba69bad3b06d450"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#aa10efd90b923c891eba69bad3b06d450">_removeMovable</a> (const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *mov)</td></tr>
<tr class="memdesc:aa10efd90b923c891eba69bad3b06d450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method for telling the node that a movable no longer intersects it.  <a href="#aa10efd90b923c891eba69bad3b06d450">More...</a><br /></td></tr>
<tr class="separator:aa10efd90b923c891eba69bad3b06d450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32f7f2ef7940f9f1236fdc6b17063ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#ac32f7f2ef7940f9f1236fdc6b17063ef">getBack</a> (void) const </td></tr>
<tr class="memdesc:ac32f7f2ef7940f9f1236fdc6b17063ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a <a class="el" href="class_ogre_1_1_bsp_node.html" title="Encapsulates a node in a BSP tree. ">BspNode</a> containing the subspace on the negative side of the splitting plane.  <a href="#ac32f7f2ef7940f9f1236fdc6b17063ef">More...</a><br /></td></tr>
<tr class="separator:ac32f7f2ef7940f9f1236fdc6b17063ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab257ed1ca61d08ca730acfdeb9d660c1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#ab257ed1ca61d08ca730acfdeb9d660c1">getBoundingBox</a> (void) const </td></tr>
<tr class="memdesc:ab257ed1ca61d08ca730acfdeb9d660c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the axis-aligned box which contains this node if it is a leaf.  <a href="#ab257ed1ca61d08ca730acfdeb9d660c1">More...</a><br /></td></tr>
<tr class="separator:ab257ed1ca61d08ca730acfdeb9d660c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210e41df7ecc16925b72a1be860eaf1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a210e41df7ecc16925b72a1be860eaf1d">getDistance</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;pos) const </td></tr>
<tr class="memdesc:a210e41df7ecc16925b72a1be860eaf1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the signed distance to the dividing plane.  <a href="#a210e41df7ecc16925b72a1be860eaf1d">More...</a><br /></td></tr>
<tr class="separator:a210e41df7ecc16925b72a1be860eaf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d74a62b0962ada93a3354d502365a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#ac4d74a62b0962ada93a3354d502365a7">getFaceGroupStart</a> (void) const </td></tr>
<tr class="memdesc:ac4d74a62b0962ada93a3354d502365a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index to the face group index list for this leaf node.  <a href="#ac4d74a62b0962ada93a3354d502365a7">More...</a><br /></td></tr>
<tr class="separator:ac4d74a62b0962ada93a3354d502365a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a70415637b4144d7540113c8f0976bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a1a70415637b4144d7540113c8f0976bb">getFront</a> (void) const </td></tr>
<tr class="memdesc:a1a70415637b4144d7540113c8f0976bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to a <a class="el" href="class_ogre_1_1_bsp_node.html" title="Encapsulates a node in a BSP tree. ">BspNode</a> containing the subspace on the positive side of the splitting plane.  <a href="#a1a70415637b4144d7540113c8f0976bb">More...</a><br /></td></tr>
<tr class="separator:a1a70415637b4144d7540113c8f0976bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ef32ad301c2cf1b427f762503b72a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a02ef32ad301c2cf1b427f762503b72a3">getNextNode</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;point) const </td></tr>
<tr class="memdesc:a02ef32ad301c2cf1b427f762503b72a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the next node down in the tree, with the intention of locating the leaf containing the given point.  <a href="#a02ef32ad301c2cf1b427f762503b72a3">More...</a><br /></td></tr>
<tr class="separator:a02ef32ad301c2cf1b427f762503b72a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e24765e11c6b8efc03db7d1043070d0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a0e24765e11c6b8efc03db7d1043070d0">getNumFaceGroups</a> (void) const </td></tr>
<tr class="memdesc:a0e24765e11c6b8efc03db7d1043070d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of faces contained in this leaf node.  <a href="#a0e24765e11c6b8efc03db7d1043070d0">More...</a><br /></td></tr>
<tr class="separator:a0e24765e11c6b8efc03db7d1043070d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33233f828bbdf5b7160a70e463c4157"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_bsp_node.html#af86ad5b76b6e2327db0e702d4216ad30">IntersectingObjectSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#aa33233f828bbdf5b7160a70e463c4157">getObjects</a> (void) const </td></tr>
<tr class="separator:aa33233f828bbdf5b7160a70e463c4157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fbeed3630e8bddb0ed3fba99f373c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_plane.html#aa5d44b14d6f032f3e0a26e83589180bc">Plane::Side</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a64fbeed3630e8bddb0ed3fba99f373c9">getSide</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;point) const </td></tr>
<tr class="memdesc:a64fbeed3630e8bddb0ed3fba99f373c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which side of the splitting plane a worldspace point is.  <a href="#a64fbeed3630e8bddb0ed3fba99f373c9">More...</a><br /></td></tr>
<tr class="separator:a64fbeed3630e8bddb0ed3fba99f373c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec9df00126e7fd14b6552788b8f5542"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_bsp_node.html#ade6cf2f9bdd72538d3b2863bfb598f98">NodeBrushList</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#aeec9df00126e7fd14b6552788b8f5542">getSolidBrushes</a> (void) const </td></tr>
<tr class="memdesc:aeec9df00126e7fd14b6552788b8f5542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main brush memory held on level.  <a href="#aeec9df00126e7fd14b6552788b8f5542">More...</a><br /></td></tr>
<tr class="separator:aeec9df00126e7fd14b6552788b8f5542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138be75d58af8407ff8eb581ef1acead"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_ogre_1_1_plane.html">Plane</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a138be75d58af8407ff8eb581ef1acead">getSplitPlane</a> (void) const </td></tr>
<tr class="memdesc:a138be75d58af8407ff8eb581ef1acead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns details of the plane which is used to subdivide the space of his node's children.  <a href="#a138be75d58af8407ff8eb581ef1acead">More...</a><br /></td></tr>
<tr class="separator:a138be75d58af8407ff8eb581ef1acead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3f25a54f243b0bed44f446e92af533"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a5c3f25a54f243b0bed44f446e92af533">isLeaf</a> (void) const </td></tr>
<tr class="memdesc:a5c3f25a54f243b0bed44f446e92af533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if this node is a leaf (i.e.  <a href="#a5c3f25a54f243b0bed44f446e92af533">More...</a><br /></td></tr>
<tr class="separator:a5c3f25a54f243b0bed44f446e92af533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851252ff648cb129cf8cb87cd7b45783"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a851252ff648cb129cf8cb87cd7b45783">isLeafVisible</a> (const <a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> *leaf) const </td></tr>
<tr class="memdesc:a851252ff648cb129cf8cb87cd7b45783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the passed in node (must also be a leaf) is visible from this leaf.  <a href="#a851252ff648cb129cf8cb87cd7b45783">More...</a><br /></td></tr>
<tr class="separator:a851252ff648cb129cf8cb87cd7b45783"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8c663a45872e4b89850c3ba482beaef5"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a8c663a45872e4b89850c3ba482beaef5">BspLevel</a></td></tr>
<tr class="separator:a8c663a45872e4b89850c3ba482beaef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1092a75e646a2cecdd62b54da97a09bc"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_bsp_node.html#a1092a75e646a2cecdd62b54da97a09bc">operator&lt;&lt;</a> (std::ostream &amp;o, <a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> &amp;n)</td></tr>
<tr class="separator:a1092a75e646a2cecdd62b54da97a09bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Encapsulates a node in a BSP tree. </p>
<p>A BSP tree represents space partitioned by planes . The space which is partitioned is either the world (in the case of the root node) or the space derived from their parent node. Each node can have elements which are in front or behind it, which are it's children and these elements can either be further subdivided by planes, or they can be undivided spaces or 'leaf nodes' - these are the nodes which actually contain objects and world geometry.The leaves of the tree are the stopping point of any tree walking algorithm, both for rendering and collision detection etc. <a class="el" href="namespace_ogre.html">Ogre</a> chooses not to represent splitting nodes and leaves as separate structures, but to merge the two for simplicity of the walking algorithm. If a node is a leaf, the <a class="el" href="class_ogre_1_1_bsp_node.html#a5c3f25a54f243b0bed44f446e92af533" title="Returns true if this node is a leaf (i.e. ">isLeaf()</a> method returns true and both <a class="el" href="class_ogre_1_1_bsp_node.html#a1a70415637b4144d7540113c8f0976bb" title="Returns a pointer to a BspNode containing the subspace on the positive side of the splitting plane...">getFront()</a> and <a class="el" href="class_ogre_1_1_bsp_node.html#ac32f7f2ef7940f9f1236fdc6b17063ef" title="Returns a pointer to a BspNode containing the subspace on the negative side of the splitting plane...">getBack()</a> return null pointers. If the node is a partitioning plane <a class="el" href="class_ogre_1_1_bsp_node.html#a5c3f25a54f243b0bed44f446e92af533" title="Returns true if this node is a leaf (i.e. ">isLeaf()</a> returns false and <a class="el" href="class_ogre_1_1_bsp_node.html#a1a70415637b4144d7540113c8f0976bb" title="Returns a pointer to a BspNode containing the subspace on the positive side of the splitting plane...">getFront()</a> and <a class="el" href="class_ogre_1_1_bsp_node.html#ac32f7f2ef7940f9f1236fdc6b17063ef" title="Returns a pointer to a BspNode containing the subspace on the negative side of the splitting plane...">getBack()</a> will return the corresponding <a class="el" href="class_ogre_1_1_bsp_node.html" title="Encapsulates a node in a BSP tree. ">BspNode</a> objects. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="af86ad5b76b6e2327db0e702d4216ad30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1set.html">set</a>&lt;const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a>*&gt;::type <a class="el" href="class_ogre_1_1_bsp_node.html#af86ad5b76b6e2327db0e702d4216ad30">Ogre::BspNode::IntersectingObjectSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ade6cf2f9bdd72538d3b2863bfb598f98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;<a class="el" href="struct_ogre_1_1_bsp_node_1_1_brush.html">Brush</a>*&gt;::type <a class="el" href="class_ogre_1_1_bsp_node.html#ade6cf2f9bdd72538d3b2863bfb598f98">Ogre::BspNode::NodeBrushList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a39b74504f7252462d27f69bbeef5dc99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::BspNode::BspNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_bsp_level.html">BspLevel</a> *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isLeaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor, only to be used by <a class="el" href="class_ogre_1_1_bsp_level.html" title="Holds all the data associated with a Binary Space Parition (BSP) based indoor level. ">BspLevel</a>. </p>

</div>
</div>
<a class="anchor" id="a10395588ed29a1d34e3b028643dd2d77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::BspNode::BspNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a74871a4318ee6f0bfdf068a988bc2496"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::BspNode::~BspNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac5702538be4c791af37cd73d2aa353a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::BspNode::_addMovable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>mov</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for telling the node that a movable intersects it. </p>

</div>
</div>
<a class="anchor" id="aa10efd90b923c891eba69bad3b06d450"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::BspNode::_removeMovable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_movable_object.html">MovableObject</a> *&#160;</td>
          <td class="paramname"><em>mov</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method for telling the node that a movable no longer intersects it. </p>

</div>
</div>
<a class="anchor" id="ac32f7f2ef7940f9f1236fdc6b17063ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a>* Ogre::BspNode::getBack </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a <a class="el" href="class_ogre_1_1_bsp_node.html" title="Encapsulates a node in a BSP tree. ">BspNode</a> containing the subspace on the negative side of the splitting plane. </p>
<p>This method should only be called on a splitting node, i.e. where <a class="el" href="class_ogre_1_1_bsp_node.html#a5c3f25a54f243b0bed44f446e92af533" title="Returns true if this node is a leaf (i.e. ">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a class="anchor" id="ab257ed1ca61d08ca730acfdeb9d660c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_axis_aligned_box.html">AxisAlignedBox</a>&amp; Ogre::BspNode::getBoundingBox </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the axis-aligned box which contains this node if it is a leaf. </p>
<p>This method should only be called on a leaf node. It returns a box which can be used in calls like <a class="el" href="class_ogre_1_1_camera.html#a2aa8b3916ca7beab3ec9654668be3703" title="Tests whether the given container is visible in the Frustum. ">Camera::isVisible</a> to determine if the leaf node is visible in the view. </p>

</div>
</div>
<a class="anchor" id="a210e41df7ecc16925b72a1be860eaf1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::BspNode::getDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the signed distance to the dividing plane. </p>

</div>
</div>
<a class="anchor" id="ac4d74a62b0962ada93a3354d502365a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::BspNode::getFaceGroupStart </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the index to the face group index list for this leaf node. </p>
<p>The contents of this buffer is a list of indexes which point to the actual face groups held in a central buffer in the <a class="el" href="class_ogre_1_1_bsp_level.html" title="Holds all the data associated with a Binary Space Parition (BSP) based indoor level. ">BspLevel</a> class (in actual fact for efficiency the indexes themselves are also held in a single buffer in <a class="el" href="class_ogre_1_1_bsp_level.html" title="Holds all the data associated with a Binary Space Parition (BSP) based indoor level. ">BspLevel</a> too). The reason for this indirection is that the buffer of indexes to face groups is organised in chunks relative to nodes, whilst the main buffer of face groups may not be. Should only be called on a leaf node. </p>

</div>
</div>
<a class="anchor" id="a1a70415637b4144d7540113c8f0976bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a>* Ogre::BspNode::getFront </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to a <a class="el" href="class_ogre_1_1_bsp_node.html" title="Encapsulates a node in a BSP tree. ">BspNode</a> containing the subspace on the positive side of the splitting plane. </p>
<p>This method should only be called on a splitting node, i.e. where <a class="el" href="class_ogre_1_1_bsp_node.html#a5c3f25a54f243b0bed44f446e92af533" title="Returns true if this node is a leaf (i.e. ">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a class="anchor" id="a02ef32ad301c2cf1b427f762503b72a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a>* Ogre::BspNode::getNextNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the next node down in the tree, with the intention of locating the leaf containing the given point. </p>
<p>This method should only be called on a splitting node, i.e. where <a class="el" href="class_ogre_1_1_bsp_node.html#a5c3f25a54f243b0bed44f446e92af533" title="Returns true if this node is a leaf (i.e. ">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a class="anchor" id="a0e24765e11c6b8efc03db7d1043070d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Ogre::BspNode::getNumFaceGroups </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of faces contained in this leaf node. </p>
<p>Should only be called on a leaf node. </p>

</div>
</div>
<a class="anchor" id="aa33233f828bbdf5b7160a70e463c4157"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_bsp_node.html#af86ad5b76b6e2327db0e702d4216ad30">IntersectingObjectSet</a>&amp; Ogre::BspNode::getObjects </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a64fbeed3630e8bddb0ed3fba99f373c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_plane.html#aa5d44b14d6f032f3e0a26e83589180bc">Plane::Side</a> Ogre::BspNode::getSide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines which side of the splitting plane a worldspace point is. </p>
<p>This method should only be called on a splitting node, i.e. where <a class="el" href="class_ogre_1_1_bsp_node.html#a5c3f25a54f243b0bed44f446e92af533" title="Returns true if this node is a leaf (i.e. ">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a class="anchor" id="aeec9df00126e7fd14b6552788b8f5542"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_bsp_node.html#ade6cf2f9bdd72538d3b2863bfb598f98">NodeBrushList</a>&amp; Ogre::BspNode::getSolidBrushes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main brush memory held on level. </p>
<p>Get the list of solid Brushes for this node. </p><dl class="section remark"><dt>Remarks</dt><dd>Only applicable for leaf nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a138be75d58af8407ff8eb581ef1acead"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_ogre_1_1_plane.html">Plane</a>&amp; Ogre::BspNode::getSplitPlane </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns details of the plane which is used to subdivide the space of his node's children. </p>
<p>This method should only be called on a splitting node, i.e. where <a class="el" href="class_ogre_1_1_bsp_node.html#a5c3f25a54f243b0bed44f446e92af533" title="Returns true if this node is a leaf (i.e. ">isLeaf()</a> returns false. Calling this method on a leaf node will throw an exception. </p>

</div>
</div>
<a class="anchor" id="a5c3f25a54f243b0bed44f446e92af533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::BspNode::isLeaf </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if this node is a leaf (i.e. </p>
<p>contains geometry) or false if it is a splitting plane. A <a class="el" href="class_ogre_1_1_bsp_node.html" title="Encapsulates a node in a BSP tree. ">BspNode</a> can either be a splitting plane (the typical representation of a BSP node) or an undivided region contining geometry (a leaf node). <a class="el" href="namespace_ogre.html">Ogre</a> represents both using the same class for simplicity of tree walking. However it is important that you use this method to determine which type you are dealing with, since certain methods are only supported with one of the subtypes. Details are given in the individual methods. Note that I could have represented splitting / leaf nodes as a class hierarchy but the virtual methods / run-time type identification would have a performance hit, and it would not make the code much (any?) simpler anyway. I think this is a fair trade-off in this case. </p>

</div>
</div>
<a class="anchor" id="a851252ff648cb129cf8cb87cd7b45783"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Ogre::BspNode::isLeafVisible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> *&#160;</td>
          <td class="paramname"><em>leaf</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the passed in node (must also be a leaf) is visible from this leaf. </p>
<p>Must only be called on a leaf node, and the parameter must also be a leaf node. If this method returns true, then the leaf passed in is visible from this leaf. Note that internally this uses the Potentially Visible Set (PVS) which is precalculated and stored with the BSP level. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a8c663a45872e4b89850c3ba482beaef5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_ogre_1_1_bsp_level.html">BspLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1092a75e646a2cecdd62b54da97a09bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_bsp_node_8h.html">OgreBspNode.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_bsp_node.html">BspNode</a></li>
    <li class="footer">Generated on Tue Nov 29 2016 01:11:59 for OGRE by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
