<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OGRE: Ogre::StaticGeometry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="doxygen-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.0git</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_ogre_1_1_static_geometry.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_ogre_1_1_static_geometry-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Ogre::StaticGeometry Class Reference<div class="ingroups"><a class="el" href="group___core.html">Core</a> &raquo; <a class="el" href="group___scene.html">Scene</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Pre-transforms and batches up meshes for efficient use as static geometry in a scene.  
 <a href="class_ogre_1_1_static_geometry.html#details">More...</a></p>

<p><code>#include &lt;OgreStaticGeometry.h&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Ogre::StaticGeometry:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_ogre_1_1_static_geometry__inherit__graph.svg" width="167" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry_1_1_geometry_bucket.html">GeometryBucket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_ogre_1_1_static_geometry_1_1_geometry_bucket.html" title="A GeometryBucket is a the lowest level bucket where geometry with the same vertex &amp; index format is s...">GeometryBucket</a> is a the lowest level bucket where geometry with the same vertex &amp; index format is stored.  <a href="class_ogre_1_1_static_geometry_1_1_geometry_bucket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry_1_1_l_o_d_bucket.html">LODBucket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_ogre_1_1_static_geometry_1_1_l_o_d_bucket.html" title="A LODBucket is a collection of smaller buckets with the same LOD. ">LODBucket</a> is a collection of smaller buckets with the same LOD.  <a href="class_ogre_1_1_static_geometry_1_1_l_o_d_bucket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry_1_1_material_bucket.html">MaterialBucket</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_ogre_1_1_static_geometry_1_1_material_bucket.html" title="A MaterialBucket is a collection of smaller buckets with the same Material (and implicitly the same L...">MaterialBucket</a> is a collection of smaller buckets with the same <a class="el" href="class_ogre_1_1_material.html" title="Class encapsulates rendering properties of an object. ">Material</a> (and implicitly the same LOD).  <a href="class_ogre_1_1_static_geometry_1_1_material_bucket.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry_1_1_optimised_sub_mesh_geometry.html">OptimisedSubMeshGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct holding geometry optimised per <a class="el" href="class_ogre_1_1_sub_mesh.html" title="Defines a part of a complete mesh. ">SubMesh</a> / LOD level, ready for copying to instances.  <a href="class_ogre_1_1_static_geometry_1_1_optimised_sub_mesh_geometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_static_geometry_1_1_queued_geometry.html">QueuedGeometry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure recording a queued geometry for low level builds.  <a href="struct_ogre_1_1_static_geometry_1_1_queued_geometry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_static_geometry_1_1_queued_sub_mesh.html">QueuedSubMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure recording a queued submesh for the build.  <a href="struct_ogre_1_1_static_geometry_1_1_queued_sub_mesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry_1_1_region.html">Region</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The details of a topological region which is the highest level of partitioning for this class.  <a href="class_ogre_1_1_static_geometry_1_1_region.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_ogre_1_1_static_geometry_1_1_sub_mesh_lod_geometry_link.html">SubMeshLodGeometryLink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saved link between <a class="el" href="class_ogre_1_1_sub_mesh.html" title="Defines a part of a complete mesh. ">SubMesh</a> at a LOD and vertex/index data May point to original or optimised geometry.  <a href="struct_ogre_1_1_static_geometry_1_1_sub_mesh_lod_geometry_link.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af4bfc42e3e7201fc0baa0285c4cd4600"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1list.html">list</a>&lt; <a class="el" href="class_ogre_1_1_static_geometry_1_1_optimised_sub_mesh_geometry.html">OptimisedSubMeshGeometry</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#af4bfc42e3e7201fc0baa0285c4cd4600">OptimisedSubMeshGeometryList</a></td></tr>
<tr class="separator:af4bfc42e3e7201fc0baa0285c4cd4600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b5977877244a32f98d5156e4f3e8ca"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; <a class="el" href="struct_ogre_1_1_static_geometry_1_1_queued_geometry.html">QueuedGeometry</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a99b5977877244a32f98d5156e4f3e8ca">QueuedGeometryList</a></td></tr>
<tr class="separator:a99b5977877244a32f98d5156e4f3e8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f16d1a633b3e8114564d3141287c11"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; <a class="el" href="struct_ogre_1_1_static_geometry_1_1_queued_sub_mesh.html">QueuedSubMesh</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#ad8f16d1a633b3e8114564d3141287c11">QueuedSubMeshList</a></td></tr>
<tr class="separator:ad8f16d1a633b3e8114564d3141287c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac58b2faf8a71daf21406ed730215a13a"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_ogre_1_1_map_iterator.html">MapIterator</a>&lt; <a class="el" href="class_ogre_1_1_static_geometry.html#afd39fb6f3b849c840c1a6c90dff499e4">RegionMap</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#ac58b2faf8a71daf21406ed730215a13a">RegionIterator</a></td></tr>
<tr class="memdesc:ac58b2faf8a71daf21406ed730215a13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator for iterating over contained regions.  <a href="#ac58b2faf8a71daf21406ed730215a13a">More...</a><br /></td></tr>
<tr class="separator:ac58b2faf8a71daf21406ed730215a13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd39fb6f3b849c840c1a6c90dff499e4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1map.html">map</a>&lt; <a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>, <a class="el" href="class_ogre_1_1_static_geometry_1_1_region.html">Region</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#afd39fb6f3b849c840c1a6c90dff499e4">RegionMap</a></td></tr>
<tr class="memdesc:afd39fb6f3b849c840c1a6c90dff499e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indexed region map based on packed x/y/z region index, 10 bits for each axis.  <a href="#afd39fb6f3b849c840c1a6c90dff499e4">More...</a><br /></td></tr>
<tr class="separator:afd39fb6f3b849c840c1a6c90dff499e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1ea3a58a6d233d3003de2ead158364"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1map.html">map</a>&lt; <a class="el" href="class_ogre_1_1_sub_mesh.html">SubMesh</a> *, <a class="el" href="class_ogre_1_1_static_geometry.html#aeb18f437d0c0f03aac5af8f3a1667444">SubMeshLodGeometryLinkList</a> * &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a3f1ea3a58a6d233d3003de2ead158364">SubMeshGeometryLookup</a></td></tr>
<tr class="separator:a3f1ea3a58a6d233d3003de2ead158364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb18f437d0c0f03aac5af8f3a1667444"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt; <a class="el" href="struct_ogre_1_1_static_geometry_1_1_sub_mesh_lod_geometry_link.html">SubMeshLodGeometryLink</a> &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#aeb18f437d0c0f03aac5af8f3a1667444">SubMeshLodGeometryLinkList</a></td></tr>
<tr class="separator:aeb18f437d0c0f03aac5af8f3a1667444"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0487dd0323485acdda054ed41f4cc216"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a0487dd0323485acdda054ed41f4cc216">StaticGeometry</a> (<a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *owner, const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;name)</td></tr>
<tr class="memdesc:a0487dd0323485acdda054ed41f4cc216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor; do not use directly (.  <a href="#a0487dd0323485acdda054ed41f4cc216">More...</a><br /></td></tr>
<tr class="separator:a0487dd0323485acdda054ed41f4cc216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d02bee2716715251c27dd9b4537c3d0"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a6d02bee2716715251c27dd9b4537c3d0">~StaticGeometry</a> ()</td></tr>
<tr class="memdesc:a6d02bee2716715251c27dd9b4537c3d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a6d02bee2716715251c27dd9b4537c3d0">More...</a><br /></td></tr>
<tr class="separator:a6d02bee2716715251c27dd9b4537c3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c44ba2920c9e07d29548d5ee927b5e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a98c44ba2920c9e07d29548d5ee927b5e">addEntity</a> (<a class="el" href="class_ogre_1_1_entity.html">Entity</a> *ent, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;position, const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;orientation=<a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a>, const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;scale=<a class="el" href="class_ogre_1_1_vector3.html#a6a27e8a3a9156701f586afeed1516fb8">Vector3::UNIT_SCALE</a>)</td></tr>
<tr class="memdesc:a98c44ba2920c9e07d29548d5ee927b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> to the static geometry.  <a href="#a98c44ba2920c9e07d29548d5ee927b5e">More...</a><br /></td></tr>
<tr class="separator:a98c44ba2920c9e07d29548d5ee927b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa077e3cb67caa3109a5664795644156a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#aa077e3cb67caa3109a5664795644156a">addSceneNode</a> (const <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *node)</td></tr>
<tr class="memdesc:aa077e3cb67caa3109a5664795644156a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all the <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> objects attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> and all it's children to the static geometry.  <a href="#aa077e3cb67caa3109a5664795644156a">More...</a><br /></td></tr>
<tr class="separator:aa077e3cb67caa3109a5664795644156a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c94e8a32918dba0fa4321e49f7135f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a03c94e8a32918dba0fa4321e49f7135f">build</a> (void)</td></tr>
<tr class="memdesc:a03c94e8a32918dba0fa4321e49f7135f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the geometry.  <a href="#a03c94e8a32918dba0fa4321e49f7135f">More...</a><br /></td></tr>
<tr class="separator:a03c94e8a32918dba0fa4321e49f7135f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5156d3d3b98d6bdb56c6c7b7d92925e8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a5156d3d3b98d6bdb56c6c7b7d92925e8">destroy</a> (void)</td></tr>
<tr class="memdesc:a5156d3d3b98d6bdb56c6c7b7d92925e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys all the built geometry state (reverse of build).  <a href="#a5156d3d3b98d6bdb56c6c7b7d92925e8">More...</a><br /></td></tr>
<tr class="separator:a5156d3d3b98d6bdb56c6c7b7d92925e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad132ec657e6e7c040b2b0231ef7b0ab9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#ad132ec657e6e7c040b2b0231ef7b0ab9">dump</a> (const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;filename) const </td></tr>
<tr class="memdesc:ad132ec657e6e7c040b2b0231ef7b0ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump the contents of this <a class="el" href="class_ogre_1_1_static_geometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene. ">StaticGeometry</a> to a file for diagnostic purposes.  <a href="#ad132ec657e6e7c040b2b0231ef7b0ab9">More...</a><br /></td></tr>
<tr class="separator:ad132ec657e6e7c040b2b0231ef7b0ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efcde5992970bde422ac7465107ee62"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a2efcde5992970bde422ac7465107ee62">getCastShadows</a> (void)</td></tr>
<tr class="memdesc:a2efcde5992970bde422ac7465107ee62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Will the geometry from this object cast shadows?  <a href="#a2efcde5992970bde422ac7465107ee62">More...</a><br /></td></tr>
<tr class="separator:a2efcde5992970bde422ac7465107ee62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1772aa923f7a9518b57419c46c0cb9c0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a1772aa923f7a9518b57419c46c0cb9c0">getName</a> (void) const </td></tr>
<tr class="memdesc:a1772aa923f7a9518b57419c46c0cb9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the name of this object.  <a href="#a1772aa923f7a9518b57419c46c0cb9c0">More...</a><br /></td></tr>
<tr class="separator:a1772aa923f7a9518b57419c46c0cb9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601e05dd3a8f93e39cf6236760d11b6f"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a601e05dd3a8f93e39cf6236760d11b6f">getOrigin</a> (void) const </td></tr>
<tr class="memdesc:a601e05dd3a8f93e39cf6236760d11b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the origin of this geometry.  <a href="#a601e05dd3a8f93e39cf6236760d11b6f">More...</a><br /></td></tr>
<tr class="separator:a601e05dd3a8f93e39cf6236760d11b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305bdacbbce5d91ef9d3dd3df7b4db8c"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a305bdacbbce5d91ef9d3dd3df7b4db8c">getRegionDimensions</a> (void) const </td></tr>
<tr class="memdesc:a305bdacbbce5d91ef9d3dd3df7b4db8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of a single batch of geometry.  <a href="#a305bdacbbce5d91ef9d3dd3df7b4db8c">More...</a><br /></td></tr>
<tr class="separator:a305bdacbbce5d91ef9d3dd3df7b4db8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483ba1dbb7fcbe2be40c6168aaea5c2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_ogre_1_1_static_geometry.html#ac58b2faf8a71daf21406ed730215a13a">RegionIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a483ba1dbb7fcbe2be40c6168aaea5c2e">getRegionIterator</a> (void)</td></tr>
<tr class="memdesc:a483ba1dbb7fcbe2be40c6168aaea5c2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator over the regions in this geometry.  <a href="#a483ba1dbb7fcbe2be40c6168aaea5c2e">More...</a><br /></td></tr>
<tr class="separator:a483ba1dbb7fcbe2be40c6168aaea5c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc64dfea292342cc15fe7b212ee9e6f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#abc64dfea292342cc15fe7b212ee9e6f5">getRenderingDistance</a> (void) const </td></tr>
<tr class="memdesc:abc64dfea292342cc15fe7b212ee9e6f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the distance at which batches are no longer rendered.  <a href="#abc64dfea292342cc15fe7b212ee9e6f5">More...</a><br /></td></tr>
<tr class="separator:abc64dfea292342cc15fe7b212ee9e6f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d74f54dfe89ad2567ace23c9dbc60ec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a6d74f54dfe89ad2567ace23c9dbc60ec">getRenderQueueGroup</a> (void) const </td></tr>
<tr class="memdesc:a6d74f54dfe89ad2567ace23c9dbc60ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the queue group for this entity, see setRenderQueueGroup for full details.  <a href="#a6d74f54dfe89ad2567ace23c9dbc60ec">More...</a><br /></td></tr>
<tr class="separator:a6d74f54dfe89ad2567ace23c9dbc60ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42fd9a095b26414d11b8a69f46ddfa4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#ab42fd9a095b26414d11b8a69f46ddfa4">getSquaredRenderingDistance</a> (void) const </td></tr>
<tr class="memdesc:ab42fd9a095b26414d11b8a69f46ddfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the squared distance at which batches are no longer rendered.  <a href="#ab42fd9a095b26414d11b8a69f46ddfa4">More...</a><br /></td></tr>
<tr class="separator:ab42fd9a095b26414d11b8a69f46ddfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1dea86d1ec8826fd9cf3a3fb99bfb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a2e1dea86d1ec8826fd9cf3a3fb99bfb1">getVisibilityFlags</a> () const </td></tr>
<tr class="memdesc:a2e1dea86d1ec8826fd9cf3a3fb99bfb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the visibility flags of the regions.  <a href="#a2e1dea86d1ec8826fd9cf3a3fb99bfb1">More...</a><br /></td></tr>
<tr class="separator:a2e1dea86d1ec8826fd9cf3a3fb99bfb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc43e2a7e7292aed18b44a9661e8ba1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a5cc43e2a7e7292aed18b44a9661e8ba1">isVisible</a> (void) const </td></tr>
<tr class="memdesc:a5cc43e2a7e7292aed18b44a9661e8ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are the batches visible?  <a href="#a5cc43e2a7e7292aed18b44a9661e8ba1">More...</a><br /></td></tr>
<tr class="separator:a5cc43e2a7e7292aed18b44a9661e8ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac5afd811992ba0967a05c92e3d75ef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a0ac5afd811992ba0967a05c92e3d75ef">reset</a> (void)</td></tr>
<tr class="memdesc:a0ac5afd811992ba0967a05c92e3d75ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears any of the entities / nodes added to this geometry and destroys anything which has already been built.  <a href="#a0ac5afd811992ba0967a05c92e3d75ef">More...</a><br /></td></tr>
<tr class="separator:a0ac5afd811992ba0967a05c92e3d75ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71907b64bca572d90168f28cb65f23cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a71907b64bca572d90168f28cb65f23cc">setCastShadows</a> (bool castShadows)</td></tr>
<tr class="memdesc:a71907b64bca572d90168f28cb65f23cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether this geometry should cast shadows.  <a href="#a71907b64bca572d90168f28cb65f23cc">More...</a><br /></td></tr>
<tr class="separator:a71907b64bca572d90168f28cb65f23cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e192ed9d7b41ae948b7ca0ed4cb5e0f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a7e192ed9d7b41ae948b7ca0ed4cb5e0f">setOrigin</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;origin)</td></tr>
<tr class="memdesc:a7e192ed9d7b41ae948b7ca0ed4cb5e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the origin of the geometry.  <a href="#a7e192ed9d7b41ae948b7ca0ed4cb5e0f">More...</a><br /></td></tr>
<tr class="separator:a7e192ed9d7b41ae948b7ca0ed4cb5e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b72934294a81bd107747a076fd8a69"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a91b72934294a81bd107747a076fd8a69">setRegionDimensions</a> (const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;size)</td></tr>
<tr class="memdesc:a91b72934294a81bd107747a076fd8a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the size of a single region of geometry.  <a href="#a91b72934294a81bd107747a076fd8a69">More...</a><br /></td></tr>
<tr class="separator:a91b72934294a81bd107747a076fd8a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275913c7bb86faf4acc86b6bd8e2a9ce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a275913c7bb86faf4acc86b6bd8e2a9ce">setRenderingDistance</a> (<a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> dist)</td></tr>
<tr class="memdesc:a275913c7bb86faf4acc86b6bd8e2a9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the distance at which batches are no longer rendered.  <a href="#a275913c7bb86faf4acc86b6bd8e2a9ce">More...</a><br /></td></tr>
<tr class="separator:a275913c7bb86faf4acc86b6bd8e2a9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce1fb9687b9023947683b881d72096b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a8ce1fb9687b9023947683b881d72096b">setRenderQueueGroup</a> (<a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> queueID)</td></tr>
<tr class="memdesc:a8ce1fb9687b9023947683b881d72096b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the render queue group this object will be rendered through.  <a href="#a8ce1fb9687b9023947683b881d72096b">More...</a><br /></td></tr>
<tr class="separator:a8ce1fb9687b9023947683b881d72096b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a3f53c1970d60f1908cac9d1cc3b1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a01a3f53c1970d60f1908cac9d1cc3b1d">setVisibilityFlags</a> (<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> flags)</td></tr>
<tr class="memdesc:a01a3f53c1970d60f1908cac9d1cc3b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the visibility flags of all the regions at once.  <a href="#a01a3f53c1970d60f1908cac9d1cc3b1d">More...</a><br /></td></tr>
<tr class="separator:a01a3f53c1970d60f1908cac9d1cc3b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d5c294946e519c0dad95dc9802609a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#ab0d5c294946e519c0dad95dc9802609a">setVisible</a> (bool visible)</td></tr>
<tr class="memdesc:ab0d5c294946e519c0dad95dc9802609a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hides or shows all the batches.  <a href="#ab0d5c294946e519c0dad95dc9802609a">More...</a><br /></td></tr>
<tr class="separator:ab0d5c294946e519c0dad95dc9802609a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83566155af8cfe9ebc83970b14978a37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_ogre_1_1_static_geometry.html#a83566155af8cfe9ebc83970b14978a37">visitRenderables</a> (<a class="el" href="class_ogre_1_1_renderable_1_1_visitor.html">Renderable::Visitor</a> *visitor, bool debugRenderables=false)</td></tr>
<tr class="memdesc:a83566155af8cfe9ebc83970b14978a37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to allow a caller to abstractly iterate over the <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement. ">Renderable</a> instances that this <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> will add to the render queue when asked, if any.  <a href="#a83566155af8cfe9ebc83970b14978a37">More...</a><br /></td></tr>
<tr class="separator:a83566155af8cfe9ebc83970b14978a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Pre-transforms and batches up meshes for efficient use as static geometry in a scene. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Modern graphics cards (GPUs) prefer to receive geometry in large batches. It is orders of magnitude faster to render 10 batches of 10,000 triangles than it is to render 10,000 batches of 10 triangles, even though both result in the same number of on-screen triangles. </dd></dl>
<dl class="section user"><dt></dt><dd>Therefore it is important when you are rendering a lot of geometry to batch things up into as few rendering calls as possible. This class allows you to build a batched object from a series of entities in order to benefit from this behaviour. Batching has implications of it's own though: <ul>
<li>Batched geometry cannot be subdivided; that means that the whole group will be displayed, or none of it will. This obivously has culling issues. </li>
<li>A single world transform must apply to the entire batch. Therefore once you have batched things, you can't move them around relative to each other. That's why this class is most useful when dealing with static geometry (hence the name). In addition, geometry is effectively duplicated, so if you add 3 entities based on the same mesh in different positions, they will use 3 times the geometry space than the movable version (which re-uses the same geometry). So you trade memory and flexibility of movement for pure speed when using this class. </li>
<li>A single material must apply for each batch. In fact this class allows you to use multiple materials, but you should be aware that internally this means that there is one batch per material. Therefore you won't gain as much benefit from the batching if you use many different materials; try to keep the number down. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>In order to retain some sort of culling, this class will batch up meshes in localised regions. The size and shape of these blocks is controlled by the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> which constructs this object, since it makes sense to batch things up in the most appropriate way given the existing partitioning of the scene. </dd></dl>
<dl class="section user"><dt></dt><dd>The LOD settings of both the <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh. ">Mesh</a> and the Materials used in constructing this static geometry will be respected. This means that if you use meshes/materials which have LOD, batches in the distance will have a lower polygon count or material detail to those in the foreground. Since each mesh might have different LOD distances, during build the furthest distance at each LOD level from all meshes in that region is used. This means all the LOD levels change at the same time, but at the furthest distance of any of them (so quality is not degraded). Be aware that using <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh. ">Mesh</a> LOD in this class will further increase the memory required. Only generated LOD is supported for meshes. </dd></dl>
<dl class="section user"><dt></dt><dd>There are 2 ways you can add geometry to this class; you can add <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> objects directly with predetermined positions, scales and orientations, or you can add an entire <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> and it's subtree, including all the objects attached to it. Once you've added everything you need to, you have to call <a class="el" href="class_ogre_1_1_static_geometry.html#a03c94e8a32918dba0fa4321e49f7135f" title="Build the geometry. ">build()</a> the fix the geometry in place. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This class is not a replacement for world geometry (</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#accb0fdfbd1f61aa4d3d6e1f4625e1f9c" title="Sets the source of the &#39;world&#39; geometry, i.e. ">SceneManager::setWorldGeometry</a>). The single most efficient way to render large amounts of static geometry is to use a <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> which is specialised for dealing with that particular world structure. However, this class does provide you with a good 'halfway house' between generalised movable geometry (<a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a>) which works with all SceneManagers but isn't efficient when using very large numbers, and highly specialised world geometry which is extremely fast but not generic and typically requires custom world editors. </dd></dl>
<dl class="section user"><dt></dt><dd>You should not construct instances of this class directly; instead, cal <a class="el" href="class_ogre_1_1_scene_manager.html#a552d1695774ca8f8da355ef0f11be86c" title="Creates a StaticGeometry instance suitable for use with this SceneManager. ">SceneManager::createStaticGeometry</a>, which gives the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> the option of providing you with a specialised version of this class if it wishes, and also handles the memory management for you like other classes. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Warning: this class only works with indexed triangle lists at the moment, do not pass it triangle strips, fans or lines / points, or unindexed geometry. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="af4bfc42e3e7201fc0baa0285c4cd4600"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1list.html">list</a>&lt;<a class="el" href="class_ogre_1_1_static_geometry_1_1_optimised_sub_mesh_geometry.html">OptimisedSubMeshGeometry</a>*&gt;::type <a class="el" href="class_ogre_1_1_static_geometry.html#af4bfc42e3e7201fc0baa0285c4cd4600">Ogre::StaticGeometry::OptimisedSubMeshGeometryList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a99b5977877244a32f98d5156e4f3e8ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;<a class="el" href="struct_ogre_1_1_static_geometry_1_1_queued_geometry.html">QueuedGeometry</a>*&gt;::type <a class="el" href="class_ogre_1_1_static_geometry.html#a99b5977877244a32f98d5156e4f3e8ca">Ogre::StaticGeometry::QueuedGeometryList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8f16d1a633b3e8114564d3141287c11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;<a class="el" href="struct_ogre_1_1_static_geometry_1_1_queued_sub_mesh.html">QueuedSubMesh</a>*&gt;::type <a class="el" href="class_ogre_1_1_static_geometry.html#ad8f16d1a633b3e8114564d3141287c11">Ogre::StaticGeometry::QueuedSubMeshList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac58b2faf8a71daf21406ed730215a13a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_ogre_1_1_map_iterator.html">MapIterator</a>&lt;<a class="el" href="class_ogre_1_1_static_geometry.html#afd39fb6f3b849c840c1a6c90dff499e4">RegionMap</a>&gt; <a class="el" href="class_ogre_1_1_static_geometry.html#ac58b2faf8a71daf21406ed730215a13a">Ogre::StaticGeometry::RegionIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator for iterating over contained regions. </p>

</div>
</div>
<a class="anchor" id="afd39fb6f3b849c840c1a6c90dff499e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1map.html">map</a>&lt;<a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>, <a class="el" href="class_ogre_1_1_static_geometry_1_1_region.html">Region</a>*&gt;::type <a class="el" href="class_ogre_1_1_static_geometry.html#afd39fb6f3b849c840c1a6c90dff499e4">Ogre::StaticGeometry::RegionMap</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indexed region map based on packed x/y/z region index, 10 bits for each axis. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Regions are indexed 0-1023 in all axes, where for example region 0 in the x axis begins at mOrigin.x + (mRegionDimensions.x * -512), and region 1023 ends at mOrigin + (mRegionDimensions.x * 512). </dd></dl>

</div>
</div>
<a class="anchor" id="a3f1ea3a58a6d233d3003de2ead158364"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1map.html">map</a>&lt;<a class="el" href="class_ogre_1_1_sub_mesh.html">SubMesh</a>*, <a class="el" href="class_ogre_1_1_static_geometry.html#aeb18f437d0c0f03aac5af8f3a1667444">SubMeshLodGeometryLinkList</a>*&gt;::type <a class="el" href="class_ogre_1_1_static_geometry.html#a3f1ea3a58a6d233d3003de2ead158364">Ogre::StaticGeometry::SubMeshGeometryLookup</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeb18f437d0c0f03aac5af8f3a1667444"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_ogre_1_1vector.html">vector</a>&lt;<a class="el" href="struct_ogre_1_1_static_geometry_1_1_sub_mesh_lod_geometry_link.html">SubMeshLodGeometryLink</a>&gt;::type <a class="el" href="class_ogre_1_1_static_geometry.html#aeb18f437d0c0f03aac5af8f3a1667444">Ogre::StaticGeometry::SubMeshLodGeometryLinkList</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0487dd0323485acdda054ed41f4cc216"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Ogre::StaticGeometry::StaticGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_scene_manager.html">SceneManager</a> *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor; do not use directly (. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_scene_manager.html#a552d1695774ca8f8da355ef0f11be86c" title="Creates a StaticGeometry instance suitable for use with this SceneManager. ">SceneManager::createStaticGeometry</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a6d02bee2716715251c27dd9b4537c3d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Ogre::StaticGeometry::~StaticGeometry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a98c44ba2920c9e07d29548d5ee927b5e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StaticGeometry::addEntity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_entity.html">Entity</a> *&#160;</td>
          <td class="paramname"><em>ent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>orientation</em> = <code><a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Quaternion::IDENTITY</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code><a class="el" href="class_ogre_1_1_vector3.html#a6a27e8a3a9156701f586afeed1516fb8">Vector3::UNIT_SCALE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> to the static geometry. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method takes an existing <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> and adds its details to the list of elements to include when building. Note that the <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> itself is not copied or referenced in this method; an <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> is passed simply so that you can change the materials of attached <a class="el" href="class_ogre_1_1_sub_entity.html" title="Utility class which defines the sub-parts of an Entity. ">SubEntity</a> objects if you want. You can add the same <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> instance multiple times with different material settings completely safely, and destroy the <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> before destroying this <a class="el" href="class_ogre_1_1_static_geometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene. ">StaticGeometry</a> if you like. The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> passed in is simply used as a definition. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Must be called before 'build'. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ent</td><td>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> to use as a definition (the <a class="el" href="class_ogre_1_1_mesh.html" title="Resource holding data about 3D mesh. ">Mesh</a> and Materials referenced will be recorded for the build call). </td></tr>
    <tr><td class="paramname">position</td><td>The world position at which to add this <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> </td></tr>
    <tr><td class="paramname">orientation</td><td>The world orientation at which to add this <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> </td></tr>
    <tr><td class="paramname">scale</td><td>The scale at which to add this entity </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa077e3cb67caa3109a5664795644156a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StaticGeometry::addSceneNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_scene_node.html">SceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all the <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> objects attached to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> and all it's children to the static geometry. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method performs just like addEntity, except it adds all the entities attached to an entire sub-tree to the geometry. The position / orientation / scale parameters are taken from the node structure instead of being specified manually. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">SceneNode</a> you pass in will not be automatically detached from it's parent, so if you have this node already attached to the scene graph, you will need to remove it if you wish to avoid the overhead of rendering <em>both</em> the original objects and their new static versions! We don't do this for you incase you are preparing this in advance and so don't want the originals detached yet. </dd>
<dd>
Must be called before 'build'. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Pointer to the node to use to provide a set of <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Entity</a> templates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a03c94e8a32918dba0fa4321e49f7135f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StaticGeometry::build </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the geometry. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Based on all the entities which have been added, and the batching options which have been set, this method constructs the batched geometry structures required. The batches are added to the scene and will be rendered unless you specifically hide them. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Once you have called this method, you can no longer add any more entities. </dd></dl>

</div>
</div>
<a class="anchor" id="a5156d3d3b98d6bdb56c6c7b7d92925e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StaticGeometry::destroy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys all the built geometry state (reverse of build). </p>
<dl class="section remark"><dt>Remarks</dt><dd>You can call <a class="el" href="class_ogre_1_1_static_geometry.html#a03c94e8a32918dba0fa4321e49f7135f" title="Build the geometry. ">build()</a> again after this and it will pick up all the same entities / nodes you queued last time. </dd></dl>

</div>
</div>
<a class="anchor" id="ad132ec657e6e7c040b2b0231ef7b0ab9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StaticGeometry::dump </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dump the contents of this <a class="el" href="class_ogre_1_1_static_geometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene. ">StaticGeometry</a> to a file for diagnostic purposes. </p>

</div>
</div>
<a class="anchor" id="a2efcde5992970bde422ac7465107ee62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::StaticGeometry::getCastShadows </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Will the geometry from this object cast shadows? </p>

</div>
</div>
<a class="anchor" id="a1772aa923f7a9518b57419c46c0cb9c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; Ogre::StaticGeometry::getName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the name of this object. </p>

<p>References <a class="el" href="class_ogre_1_1_quaternion.html#a441b8d52549e1dedec27420325a313ef">Ogre::Quaternion::IDENTITY</a>, and <a class="el" href="class_ogre_1_1_vector3.html#a6a27e8a3a9156701f586afeed1516fb8">Ogre::Vector3::UNIT_SCALE</a>.</p>

</div>
</div>
<a class="anchor" id="a601e05dd3a8f93e39cf6236760d11b6f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&amp; Ogre::StaticGeometry::getOrigin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the origin of this geometry. </p>

</div>
</div>
<a class="anchor" id="a305bdacbbce5d91ef9d3dd3df7b4db8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a>&amp; Ogre::StaticGeometry::getRegionDimensions </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the size of a single batch of geometry. </p>

</div>
</div>
<a class="anchor" id="a483ba1dbb7fcbe2be40c6168aaea5c2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_ogre_1_1_static_geometry.html#ac58b2faf8a71daf21406ed730215a13a">RegionIterator</a> Ogre::StaticGeometry::getRegionIterator </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an iterator over the regions in this geometry. </p>

</div>
</div>
<a class="anchor" id="abc64dfea292342cc15fe7b212ee9e6f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::StaticGeometry::getRenderingDistance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the distance at which batches are no longer rendered. </p>

</div>
</div>
<a class="anchor" id="a6d74f54dfe89ad2567ace23c9dbc60ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a> Ogre::StaticGeometry::getRenderQueueGroup </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the queue group for this entity, see setRenderQueueGroup for full details. </p>

</div>
</div>
<a class="anchor" id="ab42fd9a095b26414d11b8a69f46ddfa4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> Ogre::StaticGeometry::getSquaredRenderingDistance </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the squared distance at which batches are no longer rendered. </p>

</div>
</div>
<a class="anchor" id="a2e1dea86d1ec8826fd9cf3a3fb99bfb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> Ogre::StaticGeometry::getVisibilityFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the visibility flags of the regions. </p>

</div>
</div>
<a class="anchor" id="a5cc43e2a7e7292aed18b44a9661e8ba1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Ogre::StaticGeometry::isVisible </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are the batches visible? </p>

</div>
</div>
<a class="anchor" id="a0ac5afd811992ba0967a05c92e3d75ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StaticGeometry::reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears any of the entities / nodes added to this geometry and destroys anything which has already been built. </p>

</div>
</div>
<a class="anchor" id="a71907b64bca572d90168f28cb65f23cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StaticGeometry::setCastShadows </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>castShadows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether this geometry should cast shadows. </p>
<dl class="section remark"><dt>Remarks</dt><dd>No matter what the settings on the original entities, the <a class="el" href="class_ogre_1_1_static_geometry.html" title="Pre-transforms and batches up meshes for efficient use as static geometry in a scene. ">StaticGeometry</a> class defaults to not casting shadows. This is because, being static, unless you have moving lights you'd be better to use precalculated shadows of some sort. However, if you need them, you can enable them using this method. If the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">SceneManager</a> is set up to use stencil shadows, edge lists will be copied from the underlying meshes on build. It is essential that all meshes support stencil shadows in this case. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>If you intend to use stencil shadows, you must set this to true before calling 'build' as well as making sure you set the scene's shadow type (that should always be the first thing you do anyway). You can turn shadows off temporarily but they can never be turned on if they were not at the time of the build. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e192ed9d7b41ae948b7ca0ed4cb5e0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StaticGeometry::setOrigin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>origin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the origin of the geometry. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method allows you to configure the world centre of the geometry, thus the place which all regions surround. You probably don't need to mess with this unless you have a seriously large world, since the default set up can handle an area 1024 * mRegionDimensions, and the sparseness of population is no issue when it comes to rendering. The default is Vector3(0,0,0). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Must be called before 'build'. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td><a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Vector3</a> expressing the 3D origin of the geometry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a91b72934294a81bd107747a076fd8a69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StaticGeometry::setRegionDimensions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_ogre_1_1_vector3.html">Vector3</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the size of a single region of geometry. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This method allows you to configure the physical world size of each region, so you can balance culling against batch size. Entities will be fitted within the batch they most closely fit, and the eventual bounds of each batch may well be slightly larger than this if they overlap a little. The default is Vector3(1000, 1000, 1000). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Must be called before 'build'. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td><a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Vector3</a> expressing the 3D size of each region. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a275913c7bb86faf4acc86b6bd8e2a9ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StaticGeometry::setRenderingDistance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>&#160;</td>
          <td class="paramname"><em>dist</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the distance at which batches are no longer rendered. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This lets you turn off batches at a given distance. This can be useful for things like detail meshes (grass, foliage etc) and could be combined with a shader which fades the geometry out beforehand to lessen the effect. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dist</td><td>Distance beyond which the batches will not be rendered (the default is 0, which means batches are always rendered). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ce1fb9687b9023947683b881d72096b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StaticGeometry::setRenderQueueGroup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#a119732ea9d1e88bbddc47b4ac0fa21cb">uint8</a>&#160;</td>
          <td class="paramname"><em>queueID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the render queue group this object will be rendered through. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Render queues are grouped to allow you to more tightly control the ordering of rendered objects. If you do not call this method, all objects default to the default queue (<a class="el" href="class_ogre_1_1_render_queue.html#ab263254bd0c13a91c44d5fafd18c16c3" title="Gets the current default queue group, which will be used for all renderable which do not specify whic...">RenderQueue::getDefaultQueueGroup</a>), which is fine for most objects. You may want to alter this if you want to perform more complex rendering. </dd></dl>
<dl class="section user"><dt></dt><dd>See <a class="el" href="class_ogre_1_1_render_queue.html" title="Class to manage the scene object rendering queue. ">RenderQueue</a> for more details. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queueID</td><td>Enumerated value of the queue group to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01a3f53c1970d60f1908cac9d1cc3b1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::StaticGeometry::setVisibilityFlags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_ogre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the visibility flags of all the regions at once. </p>

</div>
</div>
<a class="anchor" id="ab0d5c294946e519c0dad95dc9802609a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Ogre::StaticGeometry::setVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hides or shows all the batches. </p>

</div>
</div>
<a class="anchor" id="a83566155af8cfe9ebc83970b14978a37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Ogre::StaticGeometry::visitRenderables </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_ogre_1_1_renderable_1_1_visitor.html">Renderable::Visitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debugRenderables</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Method to allow a caller to abstractly iterate over the <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement. ">Renderable</a> instances that this <a class="el" href="class_ogre_1_1_movable_object.html" title="Abstract class defining a movable object in a scene. ">MovableObject</a> will add to the render queue when asked, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visitor</td><td>Pointer to a class implementing the <a class="el" href="class_ogre_1_1_renderable_1_1_visitor.html" title="Visitor object that can be used to iterate over a collection of Renderable instances abstractly...">Renderable::Visitor</a> interface which will be called back for each <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement. ">Renderable</a> which will be queued. Bear in mind that the state of the <a class="el" href="class_ogre_1_1_renderable.html" title="Abstract class defining the interface all renderable objects must implement. ">Renderable</a> instances may not be finalised depending on when you call this. </td></tr>
    <tr><td class="paramname">debugRenderables</td><td>If false, only regular renderables will be visited (those for normal display). If true, debug renderables will be included too. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_ogre_static_geometry_8h.html">OgreStaticGeometry.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_ogre.html">Ogre</a></li><li class="navelem"><a class="el" href="class_ogre_1_1_static_geometry.html">StaticGeometry</a></li>
    <li class="footer">Generated on Tue Nov 29 2016 01:12:05 for OGRE by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
