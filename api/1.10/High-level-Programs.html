<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OGRE: High-level Programs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="doxygen-logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.0git</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('High-level-Programs.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">High-level Programs </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Skeletal-Animation-in-Vertex-Programs">Skeletal Animation in Vertex Programs</a></li>
<li class="level1"><a href="#Morph-Animation-in-Vertex-Programs">Morph Animation in Vertex Programs</a></li>
<li class="level1"><a href="#Pose-Animation-in-Vertex-Programs">Pose Animation in Vertex Programs</a></li>
<li class="level1"><a href="#Vertex-texture-fetching-in-vertex-programs">Vertex texture fetching in vertex programs</a></li>
<li class="level1"><a href="#Adjacency-information-in-Geometry-Programs">Adjacency information in Geometry Programs</a></li>
<li class="level1"><a href="#Vertex-Programs-With-Shadows">Vertex Programs With Shadows</a></li>
<li class="level1"><a href="#Cg">Cg programs</a></li>
<li class="level1"><a href="#HLSL">DirectX9 HLSL</a></li>
<li class="level1"><a href="#GLSL">OpenGL GLSL</a><ul><li class="level2"><a href="#GLSL-Texture-Samplers">GLSL Texture Samplers</a></li>
<li class="level2"><a href="#Matrix-parameters">Matrix parameters</a></li>
<li class="level2"><a href="#Accessing-OpenGL-states-in-GLSL">Accessing OpenGL states in GLSL</a></li>
<li class="level2"><a href="#Binding-vertex-attributes">Binding vertex attributes</a></li>
<li class="level2"><a href="#Preprocessor-definitions">Preprocessor definitions</a></li>
<li class="level2"><a href="#GLSL-Geometry-shader-specification">GLSL Geometry shader specification</a></li>
</ul>
</li>
<li class="level1"><a href="#Unified-High_002dlevel-Programs">Unified High-level Programs</a></li>
<li class="level1"><a href="#Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass">Using Vertex/Geometry/Fragment Programs in a Pass</a><ul><li class="level2"><a href="#Program-Parameter-Specification">Parameter specification</a></li>
</ul>
</li>
<li class="level1"><a href="#Shadows-and-Vertex-Programs">Shadows and Vertex Programs</a></li>
<li class="level1"><a href="#Vertex-Texture-Fetch">Vertex Texture Fetch</a></li>
</ul>
</div>
<div class="textblock"><p>Support for high level vertex and fragment programs is provided through plugins; this is to make sure that an application using OGRE can use as little or as much of the high-level program functionality as they like. OGRE currently supports 3 high-level program types, Cg (<a href="#Cg">Cg</a>) (an API- and card-independent, high-level language which lets you write programs for both OpenGL and DirectX for lots of cards), DirectX 9 High-Level Shader Language (<a href="#HLSL">HLSL</a>), and OpenGL Shader Language (<a href="#GLSL">GLSL</a>). HLSL can only be used with the DirectX rendersystem, and GLSL can only be used with the GL rendersystem. Cg can be used with both, although experience has shown that more advanced programs, particularly fragment programs which perform a lot of texture fetches, can produce better code in the rendersystem-specific shader language.</p>
<p>One way to support both HLSL and GLSL is to include separate techniques in the material script, each one referencing separate programs. However, if the programs are basically the same, with the same parameters, and the techniques are complex this can bloat your material scripts with duplication fairly quickly. Instead, if the only difference is the language of the vertex &amp; fragment program you can use OGRE’s <a href="#Unified-High_002dlevel-Programs">Unified High-level Programs</a> to automatically pick a program suitable for your rendersystem whilst using a single technique.</p>
<h1><a class="anchor" id="Skeletal-Animation-in-Vertex-Programs"></a>
Skeletal Animation in Vertex Programs</h1>
<p>You can implement skeletal animation in hardware by writing a vertex program which uses the per-vertex blending indices and blending weights, together with an array of world matrices (which will be provided for you by <a class="el" href="namespace_ogre.html">Ogre</a> if you bind the automatic parameter ’world_matrix_array_3x4’). However, you need to communicate this support to <a class="el" href="namespace_ogre.html">Ogre</a> so it does not perform skeletal animation in software for you. You do this by adding the following attribute to your vertex_program definition:</p>
<div class="fragment"><div class="line">includes_skeletal_animation <span class="keyword">true</span></div></div><!-- fragment --><p>When you do this, any skeletally animated entity which uses this material will forgo the usual animation blend and will expect the vertex program to do it, for both vertex positions and normals. Note that ALL submeshes must be assigned a material which implements this, and that if you combine skeletal animation with vertex animation (See <a href="#Animation">Animation</a>) then all techniques must be hardware accelerated for any to be.</p>
<h1><a class="anchor" id="Morph-Animation-in-Vertex-Programs"></a>
Morph Animation in Vertex Programs</h1>
<p>You can implement morph animation in hardware by writing a vertex program which linearly blends between the first and second position keyframes passed as positions and the first free texture coordinate set, and by binding the animation_parametric value to a parameter (which tells you how far to interpolate between the two). However, you need to communicate this support to <a class="el" href="namespace_ogre.html">Ogre</a> so it does not perform morph animation in software for you. You do this by adding the following attribute to your vertex_program definition:</p>
<div class="fragment"><div class="line">includes_morph_animation <span class="keyword">true</span></div></div><!-- fragment --><p>When you do this, any skeletally animated entity which uses this material will forgo the usual software morph and will expect the vertex program to do it. Note that if your model includes both skeletal animation and morph animation, they must both be implemented in the vertex program if either is to be hardware acceleration. Note that ALL submeshes must be assigned a material which implements this, and that if you combine skeletal animation with vertex animation (See <a href="#Animation">Animation</a>) then all techniques must be hardware accelerated for any to be.</p>
<h1><a class="anchor" id="Pose-Animation-in-Vertex-Programs"></a>
Pose Animation in Vertex Programs</h1>
<p>You can implement pose animation (blending between multiple poses based on weight) in a vertex program by pulling in the original vertex data (bound to position), and as many pose offset buffers as you’ve defined in your ’includes_pose_animation’ declaration, which will be in the first free texture unit upwards. You must also use the animation_parametric parameter to define the starting point of the constants which will contain the pose weights; they will start at the parameter you define and fill ’n’ constants, where ’n’ is the max number of poses this shader can blend, i.e. the parameter to includes_pose_animation.</p>
<div class="fragment"><div class="line">includes_pose_animation 4</div></div><!-- fragment --><p>Note that ALL submeshes must be assigned a material which implements this, and that if you combine skeletal animation with vertex animation (See <a href="#Animation">Animation</a>) then all techniques must be hardware accelerated for any to be.</p>
<h1><a class="anchor" id="Vertex-texture-fetching-in-vertex-programs"></a>
Vertex texture fetching in vertex programs</h1>
<p>If your vertex program makes use of <a href="#Vertex-Texture-Fetch">Vertex Texture Fetch</a>, you should declare that with the ’uses_vertex_texture_fetch’ directive. This is enough to tell <a class="el" href="namespace_ogre.html">Ogre</a> that your program uses this feature and that hardware support for it should be checked.</p>
<div class="fragment"><div class="line">uses_vertex_texture_fetch <span class="keyword">true</span></div></div><!-- fragment --><h1><a class="anchor" id="Adjacency-information-in-Geometry-Programs"></a>
Adjacency information in Geometry Programs</h1>
<p>Some geometry programs require adjacency information from the geometry. It means that a geometry shader doesn’t only get the information of the primitive it operates on, it also has access to its neighbours (in the case of lines or triangles). This directive will tell <a class="el" href="namespace_ogre.html">Ogre</a> to send the information to the geometry shader.</p>
<div class="fragment"><div class="line">uses_adjacency_information <span class="keyword">true</span></div></div><!-- fragment --><h1><a class="anchor" id="Vertex-Programs-With-Shadows"></a>
Vertex Programs With Shadows</h1>
<p>When using shadows (See <a class="el" href="Shadows.html">Shadows</a>), the use of vertex programs can add some additional complexities, because <a class="el" href="namespace_ogre.html">Ogre</a> can only automatically deal with everything when using the fixed-function pipeline. If you use vertex programs, and you are also using shadows, you may need to make some adjustments.</p>
<p>If you use <b>stencil shadows</b>, then any vertex programs which do vertex deformation can be a problem, because stencil shadows are calculated on the CPU, which does not have access to the modified vertices. If the vertex program is doing standard skeletal animation, this is ok (see section above) because <a class="el" href="namespace_ogre.html">Ogre</a> knows how to replicate the effect in software, but any other vertex deformation cannot be replicated, and you will either have to accept that the shadow will not reflect this deformation, or you should turn off shadows for that object.</p>
<p>If you use <b>texture shadows</b>, then vertex deformation is acceptable; however, when rendering the object into a shadow texture (the shadow caster pass), the shadow has to be rendered in a solid colour (linked to the ambient colour for modulative shadows, black for additive shadows). You must therefore provide an alternative vertex program, so <a class="el" href="namespace_ogre.html">Ogre</a> provides you with a way of specifying one to use when rendering the caster, See <a href="#Shadows-and-Vertex-Programs">Shadows and Vertex Programs</a>.</p>
<h1><a class="anchor" id="Cg"></a>
Cg programs</h1>
<p>In order to define Cg programs, you have to have to load Plugin_CgProgramManager.so/.dll at startup, either through plugins.cfg or through your own plugin loading code. They are very easy to define:</p>
<div class="fragment"><div class="line">fragment_program myCgFragmentProgram cg</div><div class="line">{</div><div class="line">    source myCgFragmentProgram.cg</div><div class="line">    entry_point main</div><div class="line">    profiles ps_2_0 arbfp1</div><div class="line">}</div></div><!-- fragment --><p>There are a few differences between this and the assembler program - to begin with, we declare that the fragment program is of type ’cg’ rather than ’asm’, which indicates that it’s a high-level program using Cg. The ’source’ parameter is the same, except this time it’s referencing a Cg source file instead of a file of assembler. Here is where things start to change. Firstly, we need to define an ’entry_point’, which is the name of a function in the Cg program which will be the first one called as part of the fragment program. Unlike assembler programs, which just run top-to-bottom, Cg programs can include multiple functions and as such you must specify the one which start the ball rolling. Next, instead of a fixed ’syntax’ parameter, you specify one or more ’profiles’; profiles are how Cg compiles a program down to the low-level assembler. The profiles have the same names as the assembler syntax codes mentioned above; the main difference is that you can list more than one, thus allowing the program to be compiled down to more low-level syntaxes so you can write a single high-level program which runs on both D3D and GL. You are advised to just enter the simplest profiles under which your programs can be compiled in order to give it the maximum compatibility. The ordering also matters; if a card supports more than one syntax then the one listed first will be used.</p>
<p>Lastly, there is a final option called ’compile_arguments’, where you can specify arguments exactly as you would to the cgc command-line compiler, should you wish to.</p>
<h1><a class="anchor" id="HLSL"></a>
DirectX9 HLSL</h1>
<p>DirectX9 HLSL has a very similar language syntax to Cg but is tied to the DirectX API. The only benefit over Cg is that it only requires the DirectX 9 render system plugin, not any additional plugins. Declaring a DirectX9 HLSL program is very similar to Cg. Here’s an example:</p>
<div class="fragment"><div class="line">vertex_program myHLSLVertexProgram hlsl</div><div class="line">{</div><div class="line">    source myHLSLVertexProgram.txt</div><div class="line">    entry_point main</div><div class="line">    target vs_2_0</div><div class="line">}</div></div><!-- fragment --><p>As you can see, the main syntax is almost identical, except that instead of ’profiles’ with a list of assembler formats, you have a ’target’ parameter which allows a single assembler target to be specified - obviously this has to be a DirectX assembler format syntax code.</p>
<p><b>Important Matrix Ordering Note:</b> One thing to bear in mind is that HLSL allows you to use 2 different ways to multiply a vector by a matrix - mul(v,m) or mul(m,v). The only difference between them is that the matrix is effectively transposed. You should use mul(m,v) with the matrices passed in from <a class="el" href="namespace_ogre.html">Ogre</a> - this agrees with the shaders produced from tools like RenderMonkey, and is consistent with Cg too, but disagrees with the Dx9 SDK and FX Composer which use mul(v,m) - you will have to switch the parameters to mul() in those shaders.</p>
<p>Note that if you use the float3x4 / matrix3x4 type in your shader, bound to an OGRE auto-definition (such as bone matrices) you should use the column_major_matrices = false option (discussed below) in your program definition. This is because OGRE passes float3x4 as row-major to save constant space (3 float4’s rather than 4 float4’s with only the top 3 values used) and this tells OGRE to pass all matrices like this, so that you can use mul(m,v) consistently for all calculations. OGRE will also to tell the shader to compile in row-major form (you don’t have to set the /Zpr compile option or #pragma pack(row-major) option, OGRE does this for you). Note that passing bones in float4x3 form is not supported by OGRE, but you don’t need it given the above.</p>
<p><b>Advanced options</b><br />
</p>
<dl compact="compact">
<dt>preprocessor_defines &lt;defines&gt; </dt>
<dd><p class="startdd"></p>
<p>This allows you to define symbols which can be used inside the HLSL shader code to alter the behaviour (through #ifdef or #if clauses). Definitions are separated by ’;’ or ’,’ and may optionally have a ’=’ operator within them to specify a definition value. Those without an ’=’ will implicitly have a definition of 1.</p>
<p class="enddd"></p>
</dd>
<dt>column_major_matrices &lt;true|false&gt; </dt>
<dd><p class="startdd"></p>
<p>The default for this option is ’true’ so that OGRE passes matrices auto-bound matrices in a form where mul(m,v) works. Setting this option to false does 2 things - it transpose auto-bound 4x4 matrices and also sets the /Zpr (row-major) option on the shader compilation. This means you can still use mul(m,v), but the matrix layout is row-major instead. This is only useful if you need to use bone matrices (float3x4) in a shader since it saves a float4 constant for every bone involved.</p>
<p class="enddd"></p>
</dd>
<dt>optimisation_level &lt;opt&gt; </dt>
<dd><p class="startdd"></p>
<p>Set the optimisation level, which can be one of ’default’, ’none’, ’0’, ’1’, ’2’, or ’3’. This corresponds to the /O parameter of fxc.exe, except that in ’default’ mode, optimisation is disabled in debug mode and set to 1 in release mode (fxc.exe uses 1 all the time). Unsurprisingly the default value is ’default’. You may want to change this if you want to tweak the optimisation, for example if your shader gets so complex that it will not longer compile without some minimum level of optimisation.</p>
<p class="enddd"></p>
</dd>
</dl>
<h1><a class="anchor" id="GLSL"></a>
OpenGL GLSL</h1>
<p>OpenGL GLSL has a similar language syntax to HLSL but is tied to the OpenGL API. The are a few benefits over Cg in that it only requires the OpenGL render system plugin, not any additional plugins. Declaring a OpenGL GLSL program is similar to Cg but simpler. Here’s an example:</p>
<div class="fragment"><div class="line">vertex_program myGLSLVertexProgram glsl</div><div class="line">{</div><div class="line">    source myGLSLVertexProgram.txt</div><div class="line">}</div></div><!-- fragment --><p>In GLSL, no entry point needs to be defined since it is always ’main()’ and there is no target definition since GLSL source is compiled into native GPU code and not intermediate assembly.</p>
<p>GLSL supports the use of modular shaders. This means you can write GLSL external functions that can be used in multiple shaders.</p>
<div class="fragment"><div class="line">vertex_program myExternalGLSLFunction1 glsl</div><div class="line">{</div><div class="line">    source myExternalGLSLfunction1.txt</div><div class="line">}</div><div class="line"></div><div class="line">vertex_program myExternalGLSLFunction2 glsl</div><div class="line">{</div><div class="line">    source myExternalGLSLfunction2.txt</div><div class="line">}</div><div class="line"></div><div class="line">vertex_program myGLSLVertexProgram1 glsl</div><div class="line">{</div><div class="line">    source myGLSLfunction.txt</div><div class="line">    attach myExternalGLSLFunction1 myExternalGLSLFunction2</div><div class="line">}</div><div class="line"></div><div class="line">vertex_program myGLSLVertexProgram2 glsl</div><div class="line">{</div><div class="line">    source myGLSLfunction.txt</div><div class="line">    attach myExternalGLSLFunction1</div><div class="line">}</div></div><!-- fragment --><p>External GLSL functions are attached to the program that needs them by using ’attach’ and including the names of all external programs required on the same line separated by spaces. This can be done for both vertex and fragment programs.</p>
<h2><a class="anchor" id="GLSL-Texture-Samplers"></a>
GLSL Texture Samplers</h2>
<p>To pass texture unit index values from the material script to texture samplers in glsl use ’int’ type named parameters. See the example below:<br />
</p>
<p>excerpt from GLSL example.frag source:</p>
<div class="fragment"><div class="line">varying vec2 UV;</div><div class="line">uniform sampler2D diffuseMap;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    gl_FragColor = texture2D(diffuseMap, UV);</div><div class="line">}</div></div><!-- fragment --><p>In material script:</p>
<div class="fragment"><div class="line">fragment_program myFragmentShader glsl</div><div class="line">{</div><div class="line">  source example.frag</div><div class="line">}</div><div class="line"></div><div class="line">material exampleGLSLTexturing</div><div class="line">{</div><div class="line">  technique</div><div class="line">  {</div><div class="line">    pass</div><div class="line">    {</div><div class="line">      fragment_program_ref myFragmentShader</div><div class="line">      {</div><div class="line">        param_named diffuseMap <span class="keywordtype">int</span> 0</div><div class="line">      }</div><div class="line"></div><div class="line">      texture_unit </div><div class="line">      {</div><div class="line">        texture myTexture.jpg 2d</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p>An index value of 0 refers to the first texture unit in the pass, an index value of 1 refers to the second unit in the pass and so on.</p>
<h2><a class="anchor" id="Matrix-parameters"></a>
Matrix parameters</h2>
<p>Here are some examples of passing matrices to GLSL mat2, mat3, mat4 uniforms:</p>
<div class="fragment"><div class="line">material exampleGLSLmatrixUniforms</div><div class="line">{</div><div class="line">  technique matrix_passing</div><div class="line">  {</div><div class="line">    pass examples</div><div class="line">    {</div><div class="line">      vertex_program_ref myVertexShader</div><div class="line">      {</div><div class="line">        <span class="comment">// mat4 uniform</span></div><div class="line">        param_named OcclusionMatrix matrix4x4 1 0 0 0  0 1 0 0  0 0 1 0  0 0 0 0 </div><div class="line">        <span class="comment">// or</span></div><div class="line">        param_named ViewMatrix float16 0 1 0 0  0 0 1 0  0 0 0 1  0 0 0 0 </div><div class="line"></div><div class="line">        <span class="comment">// mat3</span></div><div class="line">        param_named TextRotMatrix float9 1 0 0  0 1 0  0 0 1  </div><div class="line">      }</div><div class="line"></div><div class="line">      fragment_program_ref myFragmentShader</div><div class="line">      { </div><div class="line">        <span class="comment">// mat2 uniform</span></div><div class="line">        param_named skewMatrix float4 0.5 0 -0.5 1.0</div><div class="line">      }</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="Accessing-OpenGL-states-in-GLSL"></a>
Accessing OpenGL states in GLSL</h2>
<p>GLSL can access most of the GL states directly so you do not need to pass these states through <a href="#param_005fnamed_005fauto">param_named_auto</a> in the material script. This includes lights, material state, and all the matrices used in the openGL state i.e. model view matrix, worldview projection matrix etc.</p>
<h2><a class="anchor" id="Binding-vertex-attributes"></a>
Binding vertex attributes</h2>
<p>GLSL natively supports automatic binding of the most common incoming per-vertex attributes (e.g. gl_Vertex, gl_Normal, gl_MultiTexCoord0 etc). However, there are some which are not automatically bound, which must be declared in the shader using the ’attribute &lt;type&gt; &lt;name&gt;’ syntax, and the vertex data bound to it by <a class="el" href="namespace_ogre.html">Ogre</a>.</p>
<p>In addition to the built in attributes described in section 7.3 of the GLSL manual, <a class="el" href="namespace_ogre.html">Ogre</a> supports a number of automatically bound custom vertex attributes. There are some drivers that do not behave correctly when mixing built-in vertex attributes like gl_Normal and custom vertex attributes, so for maximum compatibility you may well wish to use all custom attributes in shaders where you need at least one (e.g. for skeletal animation).</p>
<dl compact="compact">
<dt>vertex </dt>
<dd><p class="startdd"></p>
<p>Binds VES_POSITION, declare as ’attribute vec4 vertex;’.</p>
<p class="enddd"></p>
</dd>
<dt>normal </dt>
<dd><p class="startdd"></p>
<p>Binds VES_NORMAL, declare as ’attribute vec3 normal;’.</p>
<p class="enddd"></p>
</dd>
<dt>colour </dt>
<dd><p class="startdd"></p>
<p>Binds VES_DIFFUSE, declare as ’attribute vec4 colour;’.</p>
<p class="enddd"></p>
</dd>
<dt>secondary_colour </dt>
<dd><p class="startdd"></p>
<p>Binds VES_SPECULAR, declare as ’attribute vec4 secondary_colour;’.</p>
<p class="enddd"></p>
</dd>
<dt>uv0 - uv7 </dt>
<dd><p class="startdd"></p>
<p>Binds VES_TEXTURE_COORDINATES, declare as ’attribute vec4 uv0;’. Note that uv6 and uv7 share attributes with tangent and binormal respectively so cannot both be present.</p>
<p class="enddd"></p>
</dd>
<dt>tangent </dt>
<dd><p class="startdd"></p>
<p>Binds VES_TANGENT, declare as ’attribute vec3 tangent;’.</p>
<p class="enddd"></p>
</dd>
<dt>binormal </dt>
<dd><p class="startdd"></p>
<p>Binds VES_BINORMAL, declare as ’attribute vec3 binormal;’.</p>
<p class="enddd"></p>
</dd>
<dt>blendIndices </dt>
<dd><p class="startdd"></p>
<p>Binds VES_BLEND_INDICES, declare as ’attribute vec4 blendIndices;’.</p>
<p class="enddd"></p>
</dd>
<dt>blendWeights </dt>
<dd><p class="startdd"></p>
<p>Binds VES_BLEND_WEIGHTS, declare as ’attribute vec4 blendWeights;’.</p>
<p class="enddd"></p>
</dd>
</dl>
<h2><a class="anchor" id="Preprocessor-definitions"></a>
Preprocessor definitions</h2>
<p>GLSL supports using preprocessor definitions in your code - some are defined by the implementation, but you can also define your own, say in order to use the same source code for a few different variants of the same technique. In order to use this feature, include preprocessor conditions in your GLSL code, of the kind #ifdef SYMBOL, #if SYMBOL==2 etc. Then in your program definition, use the ’preprocessor_defines’ option, following it with a string if definitions. Definitions are separated by ’;’ or ’,’ and may optionally have a ’=’ operator within them to specify a definition value. Those without an ’=’ will implicitly have a definition of 1. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// in your GLSL</span></div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef CLEVERTECHNIQUE</span></div><div class="line">    <span class="comment">// some clever stuff here</span></div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    <span class="comment">// normal technique</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="preprocessor">#if NUM_THINGS==2</span></div><div class="line">    <span class="comment">// Some specific code</span></div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    <span class="comment">// something else</span></div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line"><span class="comment">// in  your program definition</span></div><div class="line">preprocessor_defines CLEVERTECHNIQUE,NUMTHINGS=2</div></div><!-- fragment --><p>This way you can use the same source code but still include small variations, each one defined as a different <a class="el" href="namespace_ogre.html">Ogre</a> program name but based on the same source code.</p>
<h2><a class="anchor" id="GLSL-Geometry-shader-specification"></a>
GLSL Geometry shader specification</h2>
<p>GLSL allows the same shader to run on different types of geometry primitives. In order to properly link the shaders together, you have to specify which primitives it will receive as input, which primitives it will emit and how many vertices a single run of the shader can generate. The GLSL geometry_program definition requires three additional parameters :</p>
<dl compact="compact">
<dt>input_operation_type </dt>
<dd><p class="startdd"></p>
<p>The operation type of the geometry that the shader will receive. Can be ’point_list’, ’line_list’, ’line_strip’, ’triangle_list’, ’triangle_strip’ or ’triangle_fan’.</p>
<p class="enddd"></p>
</dd>
<dt>output_operation_type </dt>
<dd><p class="startdd"></p>
<p>The operation type of the geometry that the shader will emit. Can be ’point_list’, ’line_strip’ or ’triangle_strip’.</p>
<p class="enddd"></p>
</dd>
<dt>max_output_vertices </dt>
<dd><p class="startdd"></p>
<p>The maximum number of vertices that the shader can emit. There is an upper limit for this value, it is exposed in the render system capabilities.</p>
<p class="enddd"></p>
</dd>
</dl>
<p>For example:</p>
<div class="fragment"><div class="line">geometry_program <a class="code" href="namespace_ogre.html">Ogre</a>/GPTest/Swizzle_GP_GLSL glsl</div><div class="line">{</div><div class="line">    source SwizzleGP.glsl</div><div class="line">    input_operation_type triangle_list</div><div class="line">    output_operation_type line_strip</div><div class="line">    max_output_vertices 6</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="Unified-High_002dlevel-Programs"></a>
Unified High-level Programs</h1>
<p>As mentioned above, it can often be useful to write both HLSL and GLSL programs to specifically target each platform, but if you do this via multiple material techniques this can cause a bloated material definition when the only difference is the program language. Well, there is another option. You can ’wrap’ multiple programs in a ’unified’ program definition, which will automatically choose one of a series of ’delegate’ programs depending on the rendersystem and hardware support.</p>
<div class="fragment"><div class="line">vertex_program myVertexProgram unified</div><div class="line">{</div><div class="line">    delegate realProgram1</div><div class="line">    delegate realProgram2</div><div class="line">    ... etc</div><div class="line">}</div></div><!-- fragment --><p>This works for both vertex and fragment programs, and you can list as many delegates as you like - the first one to be supported by the current rendersystem &amp; hardware will be used as the real program. This is almost like a mini-technique system, but for a single program and with a much tighter purpose. You can only use this where the programs take all the same inputs, particularly textures and other pass / sampler state. Where the only difference between the programs is the language (or possibly the target in HLSL - you can include multiple HLSL programs with different targets in a single unified program too if you want, or indeed any number of other high-level programs), this can become a very powerful feature. For example, without this feature here’s how you’d have to define a programmable material which supported HLSL and GLSL:</p>
<div class="fragment"><div class="line">vertex_program myVertexProgramHLSL hlsl</div><div class="line">{</div><div class="line">    source prog.hlsl</div><div class="line">    entry_point main_vp</div><div class="line">    target vs_2_0</div><div class="line">}</div><div class="line">fragment_program myFragmentProgramHLSL hlsl</div><div class="line">{</div><div class="line">    source prog.hlsl</div><div class="line">    entry_point main_fp</div><div class="line">    target ps_2_0</div><div class="line">}</div><div class="line">vertex_program myVertexProgramGLSL glsl</div><div class="line">{</div><div class="line">    source prog.vert</div><div class="line">}</div><div class="line">fragment_program myFragmentProgramGLSL glsl</div><div class="line">{</div><div class="line">    source prog.frag</div><div class="line">    default_params</div><div class="line">    {</div><div class="line">        param_named tex <span class="keywordtype">int</span> 0</div><div class="line">    }</div><div class="line">}</div><div class="line">material SupportHLSLandGLSLwithoutUnified</div><div class="line">{</div><div class="line">    <span class="comment">// HLSL technique</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass</div><div class="line">        {</div><div class="line">            vertex_program_ref myVertexProgramHLSL</div><div class="line">            {</div><div class="line">                param_named_auto worldViewProj world_view_proj_matrix</div><div class="line">                param_named_auto lightColour light_diffuse_colour 0</div><div class="line">                param_named_auto lightSpecular light_specular_colour 0</div><div class="line">                param_named_auto lightAtten light_attenuation 0</div><div class="line">            }</div><div class="line">            fragment_program_ref myFragmentProgramHLSL</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">// GLSL technique</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass</div><div class="line">        {</div><div class="line">            vertex_program_ref myVertexProgramHLSL</div><div class="line">            {</div><div class="line">                param_named_auto worldViewProj world_view_proj_matrix</div><div class="line">                param_named_auto lightColour light_diffuse_colour 0</div><div class="line">                param_named_auto lightSpecular light_specular_colour 0</div><div class="line">                param_named_auto lightAtten light_attenuation 0</div><div class="line">            }</div><div class="line">            fragment_program_ref myFragmentProgramHLSL</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>And that’s a really small example. Everything you added to the HLSL technique, you’d have to duplicate in the GLSL technique too. So instead, here’s how you’d do it with unified program definitions:</p>
<div class="fragment"><div class="line">vertex_program myVertexProgramHLSL hlsl</div><div class="line">{</div><div class="line">    source prog.hlsl</div><div class="line">    entry_point main_vp</div><div class="line">    target vs_2_0</div><div class="line">}</div><div class="line">fragment_program myFragmentProgramHLSL hlsl</div><div class="line">{</div><div class="line">    source prog.hlsl</div><div class="line">    entry_point main_fp</div><div class="line">    target ps_2_0</div><div class="line">}</div><div class="line">vertex_program myVertexProgramGLSL glsl</div><div class="line">{</div><div class="line">    source prog.vert</div><div class="line">}</div><div class="line">fragment_program myFragmentProgramGLSL glsl</div><div class="line">{</div><div class="line">    source prog.frag</div><div class="line">    default_params</div><div class="line">    {</div><div class="line">        param_named tex <span class="keywordtype">int</span> 0</div><div class="line">    }</div><div class="line">}</div><div class="line"><span class="comment">// Unified definition</span></div><div class="line">vertex_program myVertexProgram unified</div><div class="line">{</div><div class="line">    delegate myVertexProgramGLSL</div><div class="line">    delegate myVertexProgramHLSL</div><div class="line">}</div><div class="line">fragment_program myFragmentProgram unified</div><div class="line">{</div><div class="line">    delegate myFragmentProgramGLSL</div><div class="line">    delegate myFragmentProgramHLSL</div><div class="line">}</div><div class="line">material SupportHLSLandGLSLwithUnified</div><div class="line">{</div><div class="line">    <span class="comment">// HLSL technique</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass</div><div class="line">        {</div><div class="line">            vertex_program_ref myVertexProgram</div><div class="line">            {</div><div class="line">                param_named_auto worldViewProj world_view_proj_matrix</div><div class="line">                param_named_auto lightColour light_diffuse_colour 0</div><div class="line">                param_named_auto lightSpecular light_specular_colour 0</div><div class="line">                param_named_auto lightAtten light_attenuation 0</div><div class="line">            }</div><div class="line">            fragment_program_ref myFragmentProgram</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>At runtime, when myVertexProgram or myFragmentProgram are used, OGRE automatically picks a real program to delegate to based on what’s supported on the current hardware / rendersystem. If none of the delegates are supported, the entire technique referencing the unified program is marked as unsupported and the next technique in the material is checked fro fallback, just like normal. As your materials get larger, and you find you need to support HLSL and GLSL specifically (or need to write multiple interface-compatible versions of a program for whatever other reason), unified programs can really help reduce duplication.</p>
<h1><a class="anchor" id="Using-Vertex_002fGeometry_002fFragment-Programs-in-a-Pass"></a>
Using Vertex/Geometry/Fragment Programs in a Pass</h1>
<p>Within a pass section of a material script, you can reference a vertex, geometry and / or a fragment program which is been defined in a .program script (See <a class="el" href="Material-Scripts.html#Declaring-Vertex_002fGeometry_002fFragment-Programs">Declaring Vertex/Geometry/Fragment Programs</a>). The programs are defined separately from the usage of them in the pass, since the programs are very likely to be reused between many separate materials, probably across many different .material scripts, so this approach lets you define the program only once and use it many times.</p>
<p>As well as naming the program in question, you can also provide parameters to it. Here’s a simple example:</p>
<div class="fragment"><div class="line">vertex_program_ref myVertexProgram</div><div class="line">{</div><div class="line">    param_indexed_auto 0 worldviewproj_matrix</div><div class="line">    param_indexed      4 float4  10.0 0 0 0</div><div class="line">}</div></div><!-- fragment --><p>In this example, we bind a vertex program called ’myVertexProgram’ (which will be defined elsewhere) to the pass, and give it 2 parameters, one is an ’auto’ parameter, meaning we do not have to supply a value as such, just a recognised code (in this case it’s the world/view/projection matrix which is kept up to date automatically by <a class="el" href="namespace_ogre.html">Ogre</a>). The second parameter is a manually specified parameter, a 4-element float. The indexes are described later.</p>
<p>The syntax of the link to a vertex program and a fragment or geometry program are identical, the only difference is that ’fragment_program_ref’ and ’geometry_program_ref’ are used respectively instead of ’vertex_program_ref’.</p>
<p>For many situations vertex, geometry and fragment programs are associated with each other in a pass but this is not cast in stone. You could have a vertex program that can be used by several different fragment programs. Another situation that arises is that you can mix fixed pipeline and programmable pipeline (shaders) together. You could use the non-programmable vertex fixed function pipeline and then provide a fragment_program_ref in a pass i.e. there would be no vertex_program_ref section in the pass. The fragment program referenced in the pass must meet the requirements as defined in the related API in order to read from the outputs of the vertex fixed pipeline. You could also just have a vertex program that outputs to the fragment fixed function pipeline.</p>
<p>The requirements to read from or write to the fixed function pipeline are similar between rendering API’s (DirectX and OpenGL) but how its actually done in each type of shader (vertex, geometry or fragment) depends on the shader language. For HLSL (DirectX API) and associated asm consult MSDN at <a href="http://msdn.microsoft.com/library/">http://msdn.microsoft.com/library/</a>. For GLSL (OpenGL), consult section 7.6 of the GLSL spec 1.1 available at <a href="http://www.opengl.org/registry/">http://www.opengl.org/registry/</a>. The built in varying variables provided in GLSL allow your program to read/write to the fixed function pipeline varyings. For Cg consult the Language Profiles section in CgUsersManual.pdf that comes with the Cg Toolkit available at <a href="https://developer.nvidia.com/cg-toolkit">https://developer.nvidia.com/cg-toolkit</a>. For HLSL and Cg its the varying bindings that allow your shader programs to read/write to the fixed function pipeline varyings.</p>
<h2><a class="anchor" id="Program-Parameter-Specification"></a>
Parameter specification</h2>
<p>Parameters can be specified using one of 4 commands as shown below. The same syntax is used whether you are defining a parameter just for this particular use of the program, or when specifying the <a href="#Default-Program-Parameters">Default Program Parameters</a>. Parameters set in the specific use of the program override the defaults.</p>
<ul>
<li><a href="#param_005findexed">param_indexed</a></li>
<li><a href="#param_005findexed_005fauto">param_indexed_auto</a></li>
<li><a href="#param_005fnamed">param_named</a></li>
<li><a href="#param_005fnamed_005fauto">param_named_auto</a></li>
<li><a href="#shared_005fparams_005fref">shared_params_ref</a></li>
</ul>
<p><a class="anchor" id="param_005findexed"></a><a class="anchor" id="param_005findexed-1"></a></p>
<h2>param_indexed</h2>
<p>This command sets the value of an indexed parameter.</p>
<p>format: param_indexed &lt;index&gt; &lt;type&gt; &lt;value&gt; example: param_indexed 0 float4 10.0 0 0 0</p>
<p>The ’index’ is simply a number representing the position in the parameter list which the value should be written, and you should derive this from your program definition. The index is relative to the way constants are stored on the card, which is in 4-element blocks. For example if you defined a float4 parameter at index 0, the next index would be 1. If you defined a matrix4x4 at index 0, the next usable index would be 4, since a 4x4 matrix takes up 4 indexes.</p>
<p>The value of ’type’ can be float4, matrix4x4, float&lt;n&gt;, int4, int&lt;n&gt;. Note that ’int’ parameters are only available on some more advanced program syntaxes, check the D3D or GL vertex / fragment program documentation for full details. Typically the most useful ones will be float4 and matrix4x4. Note that if you use a type which is not a multiple of 4, then the remaining values up to the multiple of 4 will be filled with zeroes for you (since GPUs always use banks of 4 floats per constant even if only one is used).</p>
<p>’value’ is simply a space or tab-delimited list of values which can be converted into the type you have specified.</p>
<p><a class="anchor" id="param_005findexed_005fauto"></a><a class="anchor" id="param_005findexed_005fauto-1"></a></p>
<h2>param_indexed_auto</h2>
<p>This command tells <a class="el" href="namespace_ogre.html">Ogre</a> to automatically update a given parameter with a derived value. This frees you from writing code to update program parameters every frame when they are always changing.</p>
<p>format: param_indexed_auto &lt;index&gt; &lt;value_code&gt; &lt;extra_params&gt; example: param_indexed_auto 0 worldviewproj_matrix</p>
<p>’index’ has the same meaning as <a href="#param_005findexed">param_indexed</a>; note this time you do not have to specify the size of the parameter because the engine knows this already. In the example, the world/view/projection matrix is being used so this is implicitly a matrix4x4.</p>
<p>’value_code’ is one of a list of recognised values:<br />
</p>
<dl compact="compact">
<dt>world_matrix </dt>
<dd><p class="startdd"></p>
<p>The current world matrix.</p>
<p class="enddd"></p>
</dd>
<dt>inverse_world_matrix </dt>
<dd><p class="startdd"></p>
<p>The inverse of the current world matrix.</p>
<p class="enddd"></p>
</dd>
<dt>transpose_world_matrix </dt>
<dd><p class="startdd"></p>
<p>The transpose of the world matrix</p>
<p class="enddd"></p>
</dd>
<dt>inverse_transpose_world_matrix </dt>
<dd><p class="startdd"></p>
<p>The inverse transpose of the world matrix</p>
<p class="enddd"></p>
</dd>
<dt>world_matrix_array_3x4 </dt>
<dd><p class="startdd"></p>
<p>An array of world matrices, each represented as only a 3x4 matrix (3 rows of 4columns) usually for doing hardware skinning. You should make enough entries available in your vertex program for the number of bones in use, i.e. an array of numBones*3 float4’s.</p>
<p class="enddd"></p>
</dd>
<dt>view_matrix </dt>
<dd><p class="startdd"></p>
<p>The current view matrix.</p>
<p class="enddd"></p>
</dd>
<dt>inverse_view_matrix </dt>
<dd><p class="startdd"></p>
<p>The inverse of the current view matrix.</p>
<p class="enddd"></p>
</dd>
<dt>transpose_view_matrix </dt>
<dd><p class="startdd"></p>
<p>The transpose of the view matrix</p>
<p class="enddd"></p>
</dd>
<dt>inverse_transpose_view_matrix </dt>
<dd><p class="startdd"></p>
<p>The inverse transpose of the view matrix</p>
<p class="enddd"></p>
</dd>
<dt>projection_matrix </dt>
<dd><p class="startdd"></p>
<p>The current projection matrix.</p>
<p class="enddd"></p>
</dd>
<dt>inverse_projection_matrix </dt>
<dd><p class="startdd"></p>
<p>The inverse of the projection matrix</p>
<p class="enddd"></p>
</dd>
<dt>transpose_projection_matrix </dt>
<dd><p class="startdd"></p>
<p>The transpose of the projection matrix</p>
<p class="enddd"></p>
</dd>
<dt>inverse_transpose_projection_matrix </dt>
<dd><p class="startdd"></p>
<p>The inverse transpose of the projection matrix</p>
<p class="enddd"></p>
</dd>
<dt>worldview_matrix </dt>
<dd><p class="startdd"></p>
<p>The current world and view matrices concatenated.</p>
<p class="enddd"></p>
</dd>
<dt>inverse_worldview_matrix </dt>
<dd><p class="startdd"></p>
<p>The inverse of the current concatenated world and view matrices.</p>
<p class="enddd"></p>
</dd>
<dt>transpose_worldview_matrix </dt>
<dd><p class="startdd"></p>
<p>The transpose of the world and view matrices</p>
<p class="enddd"></p>
</dd>
<dt>inverse_transpose_worldview_matrix </dt>
<dd><p class="startdd"></p>
<p>The inverse transpose of the current concatenated world and view matrices.</p>
<p class="enddd"></p>
</dd>
<dt>viewproj_matrix </dt>
<dd><p class="startdd"></p>
<p>The current view and projection matrices concatenated.</p>
<p class="enddd"></p>
</dd>
<dt>inverse_viewproj_matrix </dt>
<dd><p class="startdd"></p>
<p>The inverse of the view &amp; projection matrices</p>
<p class="enddd"></p>
</dd>
<dt>transpose_viewproj_matrix </dt>
<dd><p class="startdd"></p>
<p>The transpose of the view &amp; projection matrices</p>
<p class="enddd"></p>
</dd>
<dt>inverse_transpose_viewproj_matrix </dt>
<dd><p class="startdd"></p>
<p>The inverse transpose of the view &amp; projection matrices</p>
<p class="enddd"></p>
</dd>
<dt>worldviewproj_matrix </dt>
<dd><p class="startdd"></p>
<p>The current world, view and projection matrices concatenated.</p>
<p class="enddd"></p>
</dd>
<dt>inverse_worldviewproj_matrix </dt>
<dd><p class="startdd"></p>
<p>The inverse of the world, view and projection matrices</p>
<p class="enddd"></p>
</dd>
<dt>transpose_worldviewproj_matrix </dt>
<dd><p class="startdd"></p>
<p>The transpose of the world, view and projection matrices</p>
<p class="enddd"></p>
</dd>
<dt>inverse_transpose_worldviewproj_matrix </dt>
<dd><p class="startdd"></p>
<p>The inverse transpose of the world, view and projection matrices</p>
<p class="enddd"></p>
</dd>
<dt>texture_matrix </dt>
<dd><p class="startdd"></p>
<p>The transform matrix of a given texture unit, as it would usually be seen in the fixed-function pipeline. This requires an index in the ’extra_params’ field, and relates to the ’nth’ texture unit of the pass in question. NB if the given index exceeds the number of texture units available for this pass, then the parameter will be set to Matrix4::IDENTITY.</p>
<p class="enddd"></p>
</dd>
<dt>render_target_flipping </dt>
<dd><p class="startdd"></p>
<p>The value use to adjust transformed y position if bypassed projection matrix transform. It’s -1 if the render target requires texture flipping, +1 otherwise.</p>
<p class="enddd"></p>
</dd>
<dt>vertex_winding </dt>
<dd><p class="startdd"></p>
<p>Indicates what vertex winding mode the render state is in at this point; +1 for standard, -1 for inverted (e.g. when processing reflections).</p>
<p class="enddd"></p>
</dd>
<dt>light_diffuse_colour </dt>
<dd><p class="startdd"></p>
<p>The diffuse colour of a given light; this requires an index in the ’extra_params’ field, and relates to the ’nth’ closest light which could affect this object (i.e. 0 refers to the closest light - note that directional lights are always first in the list and always present). NB if there are no lights this close, then the parameter will be set to black.</p>
<p class="enddd"></p>
</dd>
<dt>light_specular_colour </dt>
<dd><p class="startdd"></p>
<p>The specular colour of a given light; this requires an index in the ’extra_params’ field, and relates to the ’nth’ closest light which could affect this object (i.e. 0 refers to the closest light). NB if there are no lights this close, then the parameter will be set to black.</p>
<p class="enddd"></p>
</dd>
<dt>light_attenuation </dt>
<dd><p class="startdd"></p>
<p>A float4 containing the 4 light attenuation variables for a given light. This requires an index in the ’extra_params’ field, and relates to the ’nth’ closest light which could affect this object (i.e. 0 refers to the closest light). NB if there are no lights this close, then the parameter will be set to all zeroes. The order of the parameters is range, constant attenuation, linear attenuation, quadric attenuation.</p>
<p class="enddd"></p>
</dd>
<dt>spotlight_params </dt>
<dd><p class="startdd"></p>
<p>A float4 containing the 3 spotlight parameters and a control value. The order of the parameters is cos(inner angle /2 ), cos(outer angle / 2), falloff, and the final w value is 1.0f. For non-spotlights the value is float4(1,0,0,0). This requires an index in the ’extra_params’ field, and relates to the ’nth’ closest light which could affect this object (i.e. 0 refers to the closest light). If there are less lights than this, the details are like a non-spotlight.</p>
<p class="enddd"></p>
</dd>
<dt>light_position </dt>
<dd><p class="startdd"></p>
<p>The position of a given light in world space. This requires an index in the ’extra_params’ field, and relates to the ’nth’ closest light which could affect this object (i.e. 0 refers to the closest light). NB if there are no lights this close, then the parameter will be set to all zeroes. Note that this property will work with all kinds of lights, even directional lights, since the parameter is set as a 4D vector. Point lights will be (pos.x, pos.y, pos.z, 1.0f) whilst directional lights will be (-dir.x, -dir.y, -dir.z, 0.0f). Operations like dot products will work consistently on both.</p>
<p class="enddd"></p>
</dd>
<dt>light_direction </dt>
<dd><p class="startdd"></p>
<p>The direction of a given light in world space. This requires an index in the ’extra_params’ field, and relates to the ’nth’ closest light which could affect this object (i.e. 0 refers to the closest light). NB if there are no lights this close, then the parameter will be set to all zeroes. DEPRECATED - this property only works on directional lights, and we recommend that you use light_position instead since that returns a generic 4D vector.</p>
<p class="enddd"></p>
</dd>
<dt>light_position_object_space </dt>
<dd><p class="startdd"></p>
<p>The position of a given light in object space (i.e. when the object is at (0,0,0)). This requires an index in the ’extra_params’ field, and relates to the ’nth’ closest light which could affect this object (i.e. 0 refers to the closest light). NB if there are no lights this close, then the parameter will be set to all zeroes. Note that this property will work with all kinds of lights, even directional lights, since the parameter is set as a 4D vector. Point lights will be (pos.x, pos.y, pos.z, 1.0f) whilst directional lights will be (-dir.x, -dir.y, -dir.z, 0.0f). Operations like dot products will work consistently on both.</p>
<p class="enddd"></p>
</dd>
<dt>light_direction_object_space </dt>
<dd><p class="startdd"></p>
<p>The direction of a given light in object space (i.e. when the object is at (0,0,0)). This requires an index in the ’extra_params’ field, and relates to the ’nth’ closest light which could affect this object (i.e. 0 refers to the closest light). NB if there are no lights this close, then the parameter will be set to all zeroes. DEPRECATED, except for spotlights - for directional lights we recommend that you use light_position_object_space instead since that returns a generic 4D vector.</p>
<p class="enddd"></p>
</dd>
<dt>light_distance_object_space </dt>
<dd><p class="startdd"></p>
<p>The distance of a given light from the center of the object - this is a useful approximation to per-vertex distance calculations for relatively small objects. This requires an index in the ’extra_params’ field, and relates to the ’nth’ closest light which could affect this object (i.e. 0 refers to the closest light). NB if there are no lights this close, then the parameter will be set to all zeroes.</p>
<p class="enddd"></p>
</dd>
<dt>light_position_view_space </dt>
<dd><p class="startdd"></p>
<p>The position of a given light in view space (i.e. when the camera is at (0,0,0)). This requires an index in the ’extra_params’ field, and relates to the ’nth’ closest light which could affect this object (i.e. 0 refers to the closest light). NB if there are no lights this close, then the parameter will be set to all zeroes. Note that this property will work with all kinds of lights, even directional lights, since the parameter is set as a 4D vector. Point lights will be (pos.x, pos.y, pos.z, 1.0f) whilst directional lights will be (-dir.x, -dir.y, -dir.z, 0.0f). Operations like dot products will work consistently on both.</p>
<p class="enddd"></p>
</dd>
<dt>light_direction_view_space </dt>
<dd><p class="startdd"></p>
<p>The direction of a given light in view space (i.e. when the camera is at (0,0,0)). This requires an index in the ’extra_params’ field, and relates to the ’nth’ closest light which could affect this object (i.e. 0 refers to the closest light). NB if there are no lights this close, then the parameter will be set to all zeroes. DEPRECATED, except for spotlights - for directional lights we recommend that you use light_position_view_space instead since that returns a generic 4D vector.</p>
<p class="enddd"></p>
</dd>
<dt>light_power </dt>
<dd><p class="startdd"></p>
<p>The ’power’ scaling for a given light, useful in HDR rendering. This requires an index in the ’extra_params’ field, and relates to the ’nth’ closest light which could affect this object (i.e. 0 refers to the closest light).</p>
<p class="enddd"></p>
</dd>
<dt>light_diffuse_colour_power_scaled </dt>
<dd><p class="startdd"></p>
<p>As light_diffuse_colour, except the RGB channels of the passed colour have been pre-scaled by the light’s power scaling as given by light_power.</p>
<p class="enddd"></p>
</dd>
<dt>light_specular_colour_power_scaled </dt>
<dd><p class="startdd"></p>
<p>As light_specular_colour, except the RGB channels of the passed colour have been pre-scaled by the light’s power scaling as given by light_power.</p>
<p class="enddd"></p>
</dd>
<dt>light_number </dt>
<dd><p class="startdd"></p>
<p>When rendering, there is generally a list of lights available for use by all of the passes for a given object, and those lights may or may not be referenced in one or more passes. Sometimes it can be useful to know where in that overall list a given light light (as seen from a pass) is. For example if you use iterate once_per_light, the pass always sees the light as index 0, but in each iteration the actual light referenced is different. This binding lets you pass through the actual index of the light in that overall list. You just need to give it a parameter of the pass-relative light number and it will map it to the overall list index.</p>
<p class="enddd"></p>
</dd>
<dt>light_diffuse_colour_array </dt>
<dd><p class="startdd"></p>
<p>As light_diffuse_colour, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>light_specular_colour_array </dt>
<dd><p class="startdd"></p>
<p>As light_specular_colour, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>light_diffuse_colour_power_scaled_array </dt>
<dd><p class="startdd"></p>
<p>As light_diffuse_colour_power_scaled, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>light_specular_colour_power_scaled_array </dt>
<dd><p class="startdd"></p>
<p>As light_specular_colour_power_scaled, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>light_attenuation_array </dt>
<dd><p class="startdd"></p>
<p>As light_attenuation, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>spotlight_params_array </dt>
<dd><p class="startdd"></p>
<p>As spotlight_params, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>light_position_array </dt>
<dd><p class="startdd"></p>
<p>As light_position, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>light_direction_array </dt>
<dd><p class="startdd"></p>
<p>As light_direction, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>light_position_object_space_array </dt>
<dd><p class="startdd"></p>
<p>As light_position_object_space, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>light_direction_object_space_array </dt>
<dd><p class="startdd"></p>
<p>As light_direction_object_space, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>light_distance_object_space_array </dt>
<dd><p class="startdd"></p>
<p>As light_distance_object_space, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>light_position_view_space_array </dt>
<dd><p class="startdd"></p>
<p>As light_position_view_space, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>light_direction_view_space_array </dt>
<dd><p class="startdd"></p>
<p>As light_direction_view_space, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>light_power_array </dt>
<dd><p class="startdd"></p>
<p>As light_power, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>light_count </dt>
<dd><p class="startdd"></p>
<p>The total number of lights active in this pass.</p>
<p class="enddd"></p>
</dd>
<dt>light_casts_shadows </dt>
<dd><p class="startdd"></p>
<p>Sets an integer parameter to 1 if the given light casts shadows, 0 otherwise, Requires a light index parameter.</p>
<p class="enddd"></p>
</dd>
<dt>ambient_light_colour </dt>
<dd><p class="startdd"></p>
<p>The colour of the ambient light currently set in the scene.</p>
<p class="enddd"></p>
</dd>
<dt>surface_ambient_colour </dt>
<dd><p class="startdd"></p>
<p>The ambient colour reflectance properties of the pass (See <a href="#ambient">ambient</a>). This allows you access to fixed-function pipeline property handily.</p>
<p class="enddd"></p>
</dd>
<dt>surface_diffuse_colour </dt>
<dd><p class="startdd"></p>
<p>The diffuse colour reflectance properties of the pass (See <a href="#diffuse">diffuse</a>). This allows you access to fixed-function pipeline property handily.</p>
<p class="enddd"></p>
</dd>
<dt>surface_specular_colour </dt>
<dd><p class="startdd"></p>
<p>The specular colour reflectance properties of the pass (See <a href="#specular">specular</a>). This allows you access to fixed-function pipeline property handily.</p>
<p class="enddd"></p>
</dd>
<dt>surface_emissive_colour </dt>
<dd><p class="startdd"></p>
<p>The amount of self-illumination of the pass (See <a href="#emissive">emissive</a>). This allows you access to fixed-function pipeline property handily.</p>
<p class="enddd"></p>
</dd>
<dt>surface_shininess </dt>
<dd><p class="startdd"></p>
<p>The shininess of the pass, affecting the size of specular highlights (See <a href="#specular">specular</a>). This allows you bind to fixed-function pipeline property handily.</p>
<p class="enddd"></p>
</dd>
<dt>derived_ambient_light_colour </dt>
<dd><p class="startdd"></p>
<p>The derived ambient light colour, with ’r’, ’g’, ’b’ components filled with product of surface_ambient_colour and ambient_light_colour, respectively, and ’a’ component filled with surface ambient alpha component.</p>
<p class="enddd"></p>
</dd>
<dt>derived_scene_colour </dt>
<dd><p class="startdd"></p>
<p>The derived scene colour, with ’r’, ’g’ and ’b’ components filled with sum of derived_ambient_light_colour and surface_emissive_colour, respectively, and ’a’ component filled with surface diffuse alpha component.</p>
<p class="enddd"></p>
</dd>
<dt>derived_light_diffuse_colour </dt>
<dd><p class="startdd"></p>
<p>The derived light diffuse colour, with ’r’, ’g’ and ’b’ components filled with product of surface_diffuse_colour, light_diffuse_colour and light_power, respectively, and ’a’ component filled with surface diffuse alpha component. This requires an index in the ’extra_params’ field, and relates to the ’nth’ closest light which could affect this object (i.e. 0 refers to the closest light).</p>
<p class="enddd"></p>
</dd>
<dt>derived_light_specular_colour </dt>
<dd><p class="startdd"></p>
<p>The derived light specular colour, with ’r’, ’g’ and ’b’ components filled with product of surface_specular_colour and light_specular_colour, respectively, and ’a’ component filled with surface specular alpha component. This requires an index in the ’extra_params’ field, and relates to the ’nth’ closest light which could affect this object (i.e. 0 refers to the closest light).</p>
<p class="enddd"></p>
</dd>
<dt>derived_light_diffuse_colour_array </dt>
<dd><p class="startdd"></p>
<p>As derived_light_diffuse_colour, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>derived_light_specular_colour_array </dt>
<dd><p class="startdd"></p>
<p>As derived_light_specular_colour, except that this populates an array of parameters with a number of lights, and the ’extra_params’ field refers to the number of ’nth closest’ lights to be processed. This parameter is not compatible with light-based pass_iteration options but can be used for single-pass lighting.</p>
<p class="enddd"></p>
</dd>
<dt>fog_colour </dt>
<dd><p class="startdd"></p>
<p>The colour of the fog currently set in the scene.</p>
<p class="enddd"></p>
</dd>
<dt>fog_params </dt>
<dd><p class="startdd"></p>
<p>The parameters of the fog currently set in the scene. Packed as (exp_density, linear_start, linear_end, 1.0 / (linear_end - linear_start)).</p>
<p class="enddd"></p>
</dd>
<dt>camera_position </dt>
<dd><p class="startdd"></p>
<p>The current cameras position in world space.</p>
<p class="enddd"></p>
</dd>
<dt>camera_position_object_space </dt>
<dd><p class="startdd"></p>
<p>The current cameras position in object space (i.e. when the object is at (0,0,0)).</p>
<p class="enddd"></p>
</dd>
<dt>lod_camera_position </dt>
<dd><p class="startdd"></p>
<p>The current LOD camera position in world space. A LOD camera is a separate camera associated with the rendering camera which allows LOD calculations to be calculated separately. The classic example is basing the LOD of the shadow texture render on the position of the main camera, not the shadow camera.</p>
<p class="enddd"></p>
</dd>
<dt>lod_camera_position_object_space </dt>
<dd><p class="startdd"></p>
<p>The current LOD camera position in object space (i.e. when the object is at (0,0,0)).</p>
<p class="enddd"></p>
</dd>
<dt>time </dt>
<dd><p class="startdd"></p>
<p>The current time, factored by the optional parameter (or 1.0f if not supplied).</p>
<p class="enddd"></p>
</dd>
<dt>time_0_x </dt>
<dd><p class="startdd"></p>
<p>Single float time value, which repeats itself based on "cycle time" given as an ’extra_params’ field</p>
<p class="enddd"></p>
</dd>
<dt>costime_0_x </dt>
<dd><p class="startdd"></p>
<p>Cosine of time_0_x</p>
<p class="enddd"></p>
</dd>
<dt>sintime_0_x </dt>
<dd><p class="startdd"></p>
<p>Sine of time_0_x</p>
<p class="enddd"></p>
</dd>
<dt>tantime_0_x </dt>
<dd><p class="startdd"></p>
<p>Tangent of time_0_x</p>
<p class="enddd"></p>
</dd>
<dt>time_0_x_packed </dt>
<dd><p class="startdd"></p>
<p>4-element vector of time0_x, sintime0_x, costime0_x, tantime0_x</p>
<p class="enddd"></p>
</dd>
<dt>time_0_1 </dt>
<dd><p class="startdd"></p>
<p>As time0_x but scaled to [0..1]</p>
<p class="enddd"></p>
</dd>
<dt>costime_0_1 </dt>
<dd><p class="startdd"></p>
<p>As costime0_x but scaled to [0..1]</p>
<p class="enddd"></p>
</dd>
<dt>sintime_0_1 </dt>
<dd><p class="startdd"></p>
<p>As sintime0_x but scaled to [0..1]</p>
<p class="enddd"></p>
</dd>
<dt>tantime_0_1 </dt>
<dd><p class="startdd"></p>
<p>As tantime0_x but scaled to [0..1]</p>
<p class="enddd"></p>
</dd>
<dt>time_0_1_packed </dt>
<dd><p class="startdd"></p>
<p>As time0_x_packed but all values scaled to [0..1]</p>
<p class="enddd"></p>
</dd>
<dt>time_0_2pi </dt>
<dd><p class="startdd"></p>
<p>As time0_x but scaled to [0..2*Pi]</p>
<p class="enddd"></p>
</dd>
<dt>costime_0_2pi </dt>
<dd><p class="startdd"></p>
<p>As costime0_x but scaled to [0..2*Pi]</p>
<p class="enddd"></p>
</dd>
<dt>sintime_0_2pi </dt>
<dd><p class="startdd"></p>
<p>As sintime0_x but scaled to [0..2*Pi]</p>
<p class="enddd"></p>
</dd>
<dt>tantime_0_2pi </dt>
<dd><p class="startdd"></p>
<p>As tantime0_x but scaled to [0..2*Pi]</p>
<p class="enddd"></p>
</dd>
<dt>time_0_2pi_packed </dt>
<dd><p class="startdd"></p>
<p>As time0_x_packed but scaled to [0..2*Pi]</p>
<p class="enddd"></p>
</dd>
<dt>frame_time </dt>
<dd><p class="startdd"></p>
<p>The current frame time, factored by the optional parameter (or 1.0f if not supplied).</p>
<p class="enddd"></p>
</dd>
<dt>fps </dt>
<dd><p class="startdd"></p>
<p>The current frames per second</p>
<p class="enddd"></p>
</dd>
<dt>viewport_width </dt>
<dd><p class="startdd"></p>
<p>The current viewport width in pixels</p>
<p class="enddd"></p>
</dd>
<dt>viewport_height </dt>
<dd><p class="startdd"></p>
<p>The current viewport height in pixels</p>
<p class="enddd"></p>
</dd>
<dt>inverse_viewport_width </dt>
<dd><p class="startdd"></p>
<p>1.0/the current viewport width in pixels</p>
<p class="enddd"></p>
</dd>
<dt>inverse_viewport_height </dt>
<dd><p class="startdd"></p>
<p>1.0/the current viewport height in pixels</p>
<p class="enddd"></p>
</dd>
<dt>viewport_size </dt>
<dd><p class="startdd"></p>
<p>4-element vector of viewport_width, viewport_height, inverse_viewport_width, inverse_viewport_height</p>
<p class="enddd"></p>
</dd>
<dt>texel_offsets </dt>
<dd><p class="startdd"></p>
<p>Provides details of the rendersystem-specific texture coordinate offsets required to map texels onto pixels. float4(horizontalOffset, verticalOffset, horizontalOffset / viewport_width, verticalOffset / viewport_height).</p>
<p class="enddd"></p>
</dd>
<dt>view_direction </dt>
<dd><p class="startdd"></p>
<p>View direction vector in object space</p>
<p class="enddd"></p>
</dd>
<dt>view_side_vector </dt>
<dd><p class="startdd"></p>
<p>View local X axis</p>
<p class="enddd"></p>
</dd>
<dt>view_up_vector </dt>
<dd><p class="startdd"></p>
<p>View local Y axis</p>
<p class="enddd"></p>
</dd>
<dt>fov </dt>
<dd><p class="startdd"></p>
<p>Vertical field of view, in radians</p>
<p class="enddd"></p>
</dd>
<dt>near_clip_distance </dt>
<dd><p class="startdd"></p>
<p>Near clip distance, in world units</p>
<p class="enddd"></p>
</dd>
<dt>far_clip_distance </dt>
<dd><p class="startdd"></p>
<p>Far clip distance, in world units (may be 0 for infinite view projection)</p>
<p class="enddd"></p>
</dd>
<dt>texture_viewproj_matrix </dt>
<dd><p class="startdd"></p>
<p>Applicable to vertex programs which have been specified as the ’shadow receiver’ vertex program alternative, or where a texture unit is marked as content_type shadow; this provides details of the view/projection matrix for the current shadow projector. The optional ’extra_params’ entry specifies which light the projector refers to (for the case of content_type shadow where more than one shadow texture may be present in a single pass), where 0 is the default and refers to the first light referenced in this pass.</p>
<p class="enddd"></p>
</dd>
<dt>texture_viewproj_matrix_array </dt>
<dd><p class="startdd"></p>
<p>As texture_viewproj_matrix, except an array of matrices is passed, up to the number that you specify as the ’extra_params’ value.</p>
<p class="enddd"></p>
</dd>
<dt>texture_worldviewproj_matrix </dt>
<dd><p class="startdd"></p>
<p>As texture_viewproj_matrix except it also includes the world matrix.</p>
<p class="enddd"></p>
</dd>
<dt>texture_worldviewproj_matrix_array </dt>
<dd><p class="startdd"></p>
<p>As texture_worldviewproj_matrix, except an array of matrices is passed, up to the number that you specify as the ’extra_params’ value.</p>
<p class="enddd"></p>
</dd>
<dt>spotlight_viewproj_matrix </dt>
<dd><p class="startdd"></p>
<p>Provides a view / projection matrix which matches the set up of a given spotlight (requires an ’extra_params’ entry to indicate the light index, which must be a spotlight). Can be used to project a texture from a given spotlight.</p>
<p class="enddd"></p>
</dd>
<dt>spotlight_viewproj_matrix_array </dt>
<dd><p class="startdd"></p>
<p>As spotlight_viewproj_matrix, except an array of matrices is passed, up to the number that you specify as the ’extra_params’ value.</p>
<p class="enddd"></p>
</dd>
<dt>spotlight_worldviewproj_matrix </dt>
<dd><p class="startdd"></p>
<p>As spotlight_viewproj_matrix except it also includes the world matrix.</p>
<p class="enddd"></p>
</dd>
<dt>scene_depth_range </dt>
<dd><p class="startdd"></p>
<p>Provides information about the depth range as viewed from the current camera being used to render. Provided as float4(minDepth, maxDepth, depthRange, 1 / depthRange).</p>
<p class="enddd"></p>
</dd>
<dt>shadow_scene_depth_range </dt>
<dd><p class="startdd"></p>
<p>Provides information about the depth range as viewed from the shadow camera relating to a selected light. Requires a light index parameter. Provided as float4(minDepth, maxDepth, depthRange, 1 / depthRange).</p>
<p class="enddd"></p>
</dd>
<dt>shadow_colour </dt>
<dd><p class="startdd"></p>
<p>The shadow colour (for modulative shadows) as set via SceneManager::setShadowColour.</p>
<p class="enddd"></p>
</dd>
<dt>shadow_extrusion_distance </dt>
<dd><p class="startdd"></p>
<p>The shadow extrusion distance as determined by the range of a non-directional light or set via SceneManager::setShadowDirectionalLightExtrusionDistance for directional lights.</p>
<p class="enddd"></p>
</dd>
<dt>texture_size </dt>
<dd><p class="startdd"></p>
<p>Provides texture size of the selected texture unit. Requires a texture unit index parameter. Provided as float4(width, height, depth, 1). For 2D-texture, depth sets to 1, for 1D-texture, height and depth sets to 1.</p>
<p class="enddd"></p>
</dd>
<dt>inverse_texture_size </dt>
<dd><p class="startdd"></p>
<p>Provides inverse texture size of the selected texture unit. Requires a texture unit index parameter. Provided as float4(1 / width, 1 / height, 1 / depth, 1). For 2D-texture, depth sets to 1, for 1D-texture, height and depth sets to 1.</p>
<p class="enddd"></p>
</dd>
<dt>packed_texture_size </dt>
<dd><p class="startdd"></p>
<p>Provides packed texture size of the selected texture unit. Requires a texture unit index parameter. Provided as float4(width, height, 1 / width, 1 / height). For 3D-texture, depth is ignored, for 1D-texture, height sets to 1. <a class="anchor" id="pass_005fnumber"></a></p>
<p class="enddd"></p>
</dd>
<dt>pass_number </dt>
<dd><p class="startdd"></p>
<p>Sets the active pass index number in a gpu parameter. The first pass in a technique has an index of 0, the second an index of 1 and so on. This is useful for multipass shaders (i.e. fur or blur shader) that need to know what pass it is. By setting up the auto parameter in a <a href="#Default-Program-Parameters">Default Program Parameters</a> list in a program definition, there is no requirement to set the pass number parameter in each pass and lose track. (See <a href="#fur_005fexample">fur_example</a>) <a class="anchor" id="pass_005fiteration_005fnumber"></a></p>
<p class="enddd"></p>
</dd>
<dt>pass_iteration_number </dt>
<dd><p class="startdd"></p>
<p>Useful for GPU programs that need to know what the current pass iteration number is. The first iteration of a pass is numbered 0. The last iteration number is one less than what is set for the pass iteration number. If a pass has its iteration attribute set to 5 then the last iteration number (5th execution of the pass) is 4.(See <a href="#iteration">iteration</a>) <a class="anchor" id="animation_005fparametric"></a></p>
<p class="enddd"></p>
</dd>
<dt>animation_parametric </dt>
<dd><p class="startdd"></p>
<p>Useful for hardware vertex animation. For morph animation, sets the parametric value (0..1) representing the distance between the first position keyframe (bound to positions) and the second position keyframe (bound to the first free texture coordinate) so that the vertex program can interpolate between them. For pose animation, indicates a group of up to 4 parametric weight values applying to a sequence of up to 4 poses (each one bound to x, y, z and w of the constant), one for each pose. The original positions are held in the usual position buffer, and the offsets to take those positions to the pose where weight == 1.0 are in the first ’n’ free texture coordinates; ’n’ being determined by the value passed to includes_pose_animation. If more than 4 simultaneous poses are required, then you’ll need more than 1 shader constant to hold the parametric values, in which case you should use this binding more than once, referencing a different constant entry; the second one will contain the parametrics for poses 5-8, the third for poses 9-12, and so on.</p>
<p class="enddd"></p>
</dd>
<dt>custom </dt>
<dd><p class="startdd"></p>
<p>This allows you to map a custom parameter on an individual Renderable (see Renderable::setCustomParameter) to a parameter on a GPU program. It requires that you complete the ’extra_params’ field with the index that was used in the Renderable::setCustomParameter call, and this will ensure that whenever this Renderable is used, it will have it’s custom parameter mapped in. It’s very important that this parameter has been defined on all Renderables that are assigned the material that contains this automatic mapping, otherwise the process will fail.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="param_005fnamed"></a><a class="anchor" id="param_005fnamed-1"></a></p>
<h2>param_named</h2>
<p>This is the same as param_indexed, but uses a named parameter instead of an index. This can only be used with high-level programs which include parameter names; if you’re using an assembler program then you have no choice but to use indexes. Note that you can use indexed parameters for high-level programs too, but it is less portable since if you reorder your parameters in the high-level program the indexes will change. format: param_named &lt;name&gt; &lt;type&gt; &lt;value&gt; example: param_named shininess float4 10.0 0 0 0 The type is required because the program is not compiled and loaded when the material script is parsed, so at this stage we have no idea what types the parameters are. Programs are only loaded and compiled when they are used, to save memory.</p>
<p><a class="anchor" id="param_005fnamed_005fauto"></a><a class="anchor" id="param_005fnamed_005fauto-1"></a></p>
<h2>param_named_auto</h2>
<p>This is the named equivalent of param_indexed_auto, for use with high-level programs. Format: param_named_auto &lt;name&gt; &lt;value_code&gt; &lt;extra_params&gt; Example: param_named_auto worldViewProj WORLDVIEWPROJ_MATRIX</p>
<p>The allowed value codes and the meaning of extra_params are detailed in <a href="#param_005findexed_005fauto">param_indexed_auto</a>.</p>
<p><a class="anchor" id="shared_005fparams_005fref"></a><a class="anchor" id="shared_005fparams_005fref-1"></a></p>
<h2>shared_params_ref</h2>
<p>This option allows you to reference shared parameter sets as defined in <a href="#Declaring-Shared-Parameters">Declaring Shared Parameters</a>. Format: shared_params_ref &lt;shared_set_name&gt; Example: shared_params_ref mySharedParams</p>
<p>The only required parameter is a name, which must be the name of an already defined shared parameter set. All named parameters which are present in the program that are also present in the shared parameter set will be linked, and the shared parameters used as if you had defined them locally. This is dependent on the definitions (type and array size) matching between the shared set and the program.</p>
<h1><a class="anchor" id="Shadows-and-Vertex-Programs"></a>
Shadows and Vertex Programs</h1>
<p>When using shadows (See <a class="el" href="Shadows.html">Shadows</a>), the use of vertex programs can add some additional complexities, because <a class="el" href="namespace_ogre.html">Ogre</a> can only automatically deal with everything when using the fixed-function pipeline. If you use vertex programs, and you are also using shadows, you may need to make some adjustments.</p>
<p>If you use <b>stencil shadows</b>, then any vertex programs which do vertex deformation can be a problem, because stencil shadows are calculated on the CPU, which does not have access to the modified vertices. If the vertex program is doing standard skeletal animation, this is ok (see section above) because <a class="el" href="namespace_ogre.html">Ogre</a> knows how to replicate the effect in software, but any other vertex deformation cannot be replicated, and you will either have to accept that the shadow will not reflect this deformation, or you should turn off shadows for that object.</p>
<p>If you use <b>texture shadows</b>, then vertex deformation is acceptable; however, when rendering the object into the shadow texture (the shadow caster pass), the shadow has to be rendered in a solid colour (linked to the ambient colour). You must therefore provide an alternative vertex program, so <a class="el" href="namespace_ogre.html">Ogre</a> provides you with a way of specifying one to use when rendering the caster. Basically you link an alternative vertex program, using exactly the same syntax as the original vertex program link:</p>
<div class="fragment"><div class="line">shadow_caster_vertex_program_ref myShadowCasterVertexProgram</div><div class="line">{</div><div class="line">    param_indexed_auto 0 worldviewproj_matrix</div><div class="line">    param_indexed_auto 4 ambient_light_colour</div><div class="line">}</div></div><!-- fragment --><p>When rendering a shadow caster, <a class="el" href="namespace_ogre.html">Ogre</a> will automatically use the alternate program. You can bind the same or different parameters to the program - the most important thing is that you bind <b>ambient_light_colour</b>, since this determines the colour of the shadow in modulative texture shadows. If you don’t supply an alternate program, <a class="el" href="namespace_ogre.html">Ogre</a> will fall back on a fixed-function material which will not reflect any vertex deformation you do in your vertex program.</p>
<p>In addition, when rendering the shadow receivers with shadow textures, <a class="el" href="namespace_ogre.html">Ogre</a> needs to project the shadow texture. It does this automatically in fixed function mode, but if the receivers use vertex programs, they need to have a shadow receiver program which does the usual vertex deformation, but also generates projective texture coordinates. The additional program linked into the pass like this:</p>
<div class="fragment"><div class="line">shadow_receiver_vertex_program_ref myShadowReceiverVertexProgram</div><div class="line">{</div><div class="line">    param_indexed_auto 0 worldviewproj_matrix</div><div class="line">    param_indexed_auto 4 texture_viewproj_matrix</div><div class="line">}</div></div><!-- fragment --><p>For the purposes of writing this alternate program, there is an automatic parameter binding of ’texture_viewproj_matrix’ which provides the program with texture projection parameters. The vertex program should do it’s normal vertex processing, and generate texture coordinates using this matrix and place them in texture coord sets 0 and 1, since some shadow techniques use 2 texture units. The colour of the vertices output by this vertex program must always be white, so as not to affect the final colour of the rendered shadow.</p>
<p>When using additive texture shadows, the shadow pass render is actually the lighting render, so if you perform any fragment program lighting you also need to pull in a custom fragment program. You use the shadow_receiver_fragment_program_ref for this:</p>
<div class="fragment"><div class="line">shadow_receiver_fragment_program_ref myShadowReceiverFragmentProgram</div><div class="line">{</div><div class="line">    param_named_auto lightDiffuse light_diffuse_colour 0 </div><div class="line">}</div></div><!-- fragment --><p>You should pass the projected shadow coordinates from the custom vertex program. As for textures, texture unit 0 will always be the shadow texture. Any other textures which you bind in your pass will be carried across too, but will be moved up by 1 unit to make room for the shadow texture. Therefore your shadow receiver fragment program is likely to be the same as the bare lighting pass of your normal material, except that you insert an extra texture sampler at index 0, which you will use to adjust the result by (modulating diffuse and specular components).</p>
<h1><a class="anchor" id="Vertex-Texture-Fetch"></a>
Vertex Texture Fetch</h1>
<p>More recent generations of video card allow you to perform a read from a texture in the vertex program rather than just the fragment program, as is traditional. This allows you to, for example, read the contents of a texture and displace vertices based on the intensity of the colour contained within.</p>
<p><a class="anchor" id="Declaring-the-use-of-vertex-texture-fetching"></a></p>
<h2>Declaring the use of vertex texture fetching</h2>
<p>Since hardware support for vertex texture fetching is not ubiquitous, you should use the uses_vertex_texture_fetch (See <a href="#Vertex-texture-fetching-in-vertex-programs">Vertex texture fetching in vertex programs</a>) directive when declaring your vertex programs which use vertex textures, so that if it is not supported, technique fallback can be enabled. This is not strictly necessary for DirectX-targeted shaders, since vertex texture fetching is only supported in vs_3_0, which can be stated as a required syntax in your shader definition, but for OpenGL (GLSL), there are cards which support GLSL but not vertex textures, so you should be explicit about your need for them.</p>
<p><a class="anchor" id="Render-system-texture-binding-differences"></a></p>
<h2>Render system texture binding differences</h2>
<p>Unfortunately the method for binding textures so that they are available to a vertex program is not well standardised. As at the time of writing, Shader Model 3.0 (SM3.0) hardware under DirectX9 include 4 separate sampler bindings for the purposes of vertex textures. OpenGL, on the other hand, is able to access vertex textures in GLSL (and in assembler through NV_vertex_program_3, although this is less popular), but the textures are shared with the fragment pipeline. I expect DirectX to move to the GL model with the advent of DirectX10, since a unified shader architecture implies sharing of texture resources between the two stages. As it is right now though, we’re stuck with an inconsistent situation.</p>
<p>To reflect this, you should use the <a href="#binding_005ftype">binding_type</a> attribute in a texture unit to indicate which unit you are targeting with your texture - ’fragment’ (the default) or ’vertex’. For render systems that don’t have separate bindings, this actually does nothing. But for those that do, it will ensure your texture gets bound to the right processing unit.</p>
<p>Note that whilst DirectX9 has separate bindings for the vertex and fragment pipelines, binding a texture to the vertex processing unit still uses up a ’slot’ which is then not available for use in the fragment pipeline. I didn’t manage to find this documented anywhere, but the nVidia samples certainly avoid binding a texture to the same index on both vertex and fragment units, and when I tried to do it, the texture did not appear correctly in the fragment unit, whilst it did as soon as I moved it into the next unit.</p>
<p><a class="anchor" id="Texture-format-limitations"></a></p>
<h2>Texture format limitations</h2>
<p>Again as at the time of writing, the types of texture you can use in a vertex program are limited to 1- or 4-component, full precision floating point formats. In code that equates to PF_FLOAT32_R or PF_FLOAT32_RGBA. No other formats are supported. In addition, the textures must be regular 2D textures (no cube or volume maps) and mipmapping and filtering is not supported, although you can perform filtering in your vertex program if you wish by sampling multiple times.</p>
<p><a class="anchor" id="Hardware-limitations"></a></p>
<h2>Hardware limitations</h2>
<p>As at the time of writing (early Q3 2006), ATI do not support texture fetch in their current crop of cards (Radeon X1n00). nVidia do support it in both their 6n00 and 7n00 range. ATI support an alternative called ’Render to Vertex Buffer’, but this is not standardised at this time and is very much different in its implementation, so cannot be considered to be a drop-in replacement. This is the case even though the Radeon X1n00 cards claim to support vs_3_0 (which requires vertex texture fetch). </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="manual.html">Manual</a></li><li class="navelem"><a class="el" href="Scripts.html">Scripts</a></li><li class="navelem"><a class="el" href="Material-Scripts.html">Material Scripts</a></li>
    <li class="footer">Generated on Tue Nov 29 2016 01:11:59 for OGRE by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
